using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Domain.SourceGenerator;

/// <summary>
/// Source generator: detects classes marked with SnapshotableAttribute and generates snapshot classes and extension methods.
/// </summary>
[Generator]
public class SnapshotGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all classes with SnapshotableAttribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Register output generation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item2, spc));
    }

    /// <summary>
    /// Determines whether the syntax node is a target (class declaration with attributes).
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // Only interested in class declarations
        if (node is ClassDeclarationSyntax classDeclaration)
        {
            // Check if the class has attribute lists
            return classDeclaration.AttributeLists.Count > 0;
        }
        return false;
    }

    /// <summary>
    /// Gets the target class from the semantic model (class with SnapshotableAttribute).
    /// </summary>
    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // Get the semantic model of the class
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol is null)
        {
            return null;
        }

        // Check if the class has SnapshotableAttribute
        var hasSnapshotableAttribute = classSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString().EndsWith("SnapshotableAttribute") == true);

        return hasSnapshotableAttribute ? classSymbol : null;
    }

    /// <summary>
    /// Executes code generation.
    /// </summary>
    private static void Execute(ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        // Filter out null values
        var snapshotableClasses = classes.Where(c => c is not null).Cast<INamedTypeSymbol>().ToList();

        if (snapshotableClasses.Count == 0)
        {
            return;
        }

        // Build a set of all snapshotable type names (without nullable annotations)
        var snapshotableTypeNames = new HashSet<string>(snapshotableClasses.Select(c =>
            c.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes))));

        // Generate snapshot class and extension methods for each class
        foreach (var classSymbol in snapshotableClasses)
        {
            var source = GenerateSnapshotAndExtension(classSymbol, snapshotableTypeNames);
            var fileName = $"{classSymbol.Name}Snapshot.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    /// <summary>
    /// Generates the snapshot class and extension method code.
    /// </summary>
    private static string GenerateSnapshotAndExtension(INamedTypeSymbol classSymbol, HashSet<string> snapshotableTypeNames)
    {
        var className = classSymbol.Name;
        var snapshotClassName = $"{className}Snapshot";
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Get all public properties
        var properties = GetPublicProperties(classSymbol);

        // Generate snapshot class (using record with primary constructor)
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Snapshot class for {className}.");
        sb.AppendLine("    /// </summary>");

        // Build primary constructor parameter list
        var constructorParams = properties
            .Select(property => new
            {
                property,
                propertyType =
                    GetFullyQualifiedSnapshotPropertyType(property.Type, snapshotableTypeNames)
            })
            .Select(t => new { t, propertyName = t.property.Name })
            .Select(t => $"{t.t.propertyType} {t.propertyName}").ToList();

        var paramsString = string.Join(", ", constructorParams);
        sb.AppendLine($"    public record {snapshotClassName}({paramsString});");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Snapshot extension methods for {className}.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static partial class SnapshotExtensions");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Creates a snapshot of {className}.");
        sb.AppendLine("        /// </summary>");

        var fullClassName = classSymbol.ToDisplayString();
        sb.AppendLine($"        public static {namespaceName}.{snapshotClassName} ToSnapshot(this {fullClassName} source)");
        sb.AppendLine("        {");

        // Generate record constructor call
        sb.Append($"            return new {namespaceName}.{snapshotClassName}(");

        // Generate constructor arguments
        var paramMappings = properties.Select(property =>
        {
            var propertyName = property.Name;
            // Get fully qualified type name without nullable annotation (for snapshotable type check)
            var propertyTypeFullName = property.Type.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));
            var isNullable = property.Type.NullableAnnotation == NullableAnnotation.Annotated;

            // Check if the property type is a snapshotable type
            if (snapshotableTypeNames.Contains(propertyTypeFullName))
            {
                // If snapshotable, call its ToSnapshot method.
                // Use ?. for nullable types, . for non-nullable types.
                return isNullable
                    ? $"source.{propertyName}?.ToSnapshot()"
                    : $"source.{propertyName}.ToSnapshot()";
            }

            // Otherwise, assign directly
            return $"source.{propertyName}";
        }).ToList();

        sb.Append(string.Join(", ", paramMappings));
        sb.AppendLine(");");

        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Gets all public properties of the class.
    /// </summary>
    private static List<IPropertySymbol> GetPublicProperties(INamedTypeSymbol classSymbol)
    {
        var properties = new List<IPropertySymbol>();

        foreach (var member in classSymbol.GetMembers())
        {
            if (member is not IPropertySymbol { DeclaredAccessibility: Accessibility.Public, IsStatic: false } property)
            {
                continue;
            }
            if (property.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString().EndsWith("SnapshotIgnoreAttribute") == true))
            {
                continue;
            }

            properties.Add(property);
        }

        return properties;
    }

    /// <summary>
    /// Gets the fully qualified snapshot property type (maps snapshotable types to their snapshot type names).
    /// </summary>
    private static string GetFullyQualifiedSnapshotPropertyType(ITypeSymbol typeSymbol, HashSet<string> snapshotableTypeNames)
    {
        // Get fully qualified type name without nullable annotation (for snapshotable type check)
        var typeFullNameWithoutNullable = typeSymbol.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));

        // Check if the original type is nullable
        var isNullable = typeSymbol.NullableAnnotation == NullableAnnotation.Annotated;

        // Check if it is a snapshotable type
        if (!snapshotableTypeNames.Contains(typeFullNameWithoutNullable.TrimEnd('?')))
        {
            // Not a snapshotable type, return the original fully qualified name (preserving nullability)
            return typeSymbol.ToDisplayString();
        }

        // Is a snapshotable type, map to snapshot type
        // Get the type's namespace and name
        var typeNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;

        // Return the fully qualified snapshot type name, preserving original nullability
        return isNullable
            ? $"{typeNamespace}.{typeName}Snapshot?"
            : $"{typeNamespace}.{typeName}Snapshot";
    }
}
