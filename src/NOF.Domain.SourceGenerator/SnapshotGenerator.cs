using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Domain.SourceGenerator;

/// <summary>
/// 源生成器：检测标记了SnapshotableAttribute的类，并生成快照类和扩展方法
/// </summary>
[Generator]
public class SnapshotGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取所有带有SnapshotableAttribute的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // 注册输出生成
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item2, spc));
    }

    /// <summary>
    /// 判断语法节点是否是我们关注的目标（带有Attribute的类声明）
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // 只关注类声明
        if (node is ClassDeclarationSyntax classDeclaration)
        {
            // 检查类是否有特性列表
            return classDeclaration.AttributeLists.Count > 0;
        }
        return false;
    }

    /// <summary>
    /// 获取语义模型中的目标类（带有SnapshotableAttribute的类）
    /// </summary>
    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // 获取类的语义模型
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol is null)
        {
            return null;
        }

        // 检查类是否有SnapshotableAttribute
        var hasSnapshotableAttribute = classSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString().EndsWith("SnapshotableAttribute") == true);

        return hasSnapshotableAttribute ? classSymbol : null;
    }

    /// <summary>
    /// 执行代码生成
    /// </summary>
    private static void Execute(ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        // 过滤掉null值
        var snapshotableClasses = classes.Where(c => c is not null).Cast<INamedTypeSymbol>().ToList();

        if (snapshotableClasses.Count == 0)
        {
            return;
        }

        // 构建所有可快照类型的集合（不包含可空注解）
        var snapshotableTypeNames = new HashSet<string>(snapshotableClasses.Select(c =>
            c.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes))));

        // 为每个类生成快照类和扩展方法
        foreach (var classSymbol in snapshotableClasses)
        {
            var source = GenerateSnapshotAndExtension(classSymbol, snapshotableTypeNames);
            var fileName = $"{classSymbol.Name}Snapshot.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    /// <summary>
    /// 生成快照类和扩展方法的代码
    /// </summary>
    private static string GenerateSnapshotAndExtension(INamedTypeSymbol classSymbol, HashSet<string> snapshotableTypeNames)
    {
        var className = classSymbol.Name;
        var snapshotClassName = $"{className}Snapshot";
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // 获取所有公开属性
        var properties = GetPublicProperties(classSymbol);

        // 生成快照类（使用 record 和 primary constructor）
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {className} 的快照类");
        sb.AppendLine("    /// </summary>");

        // 构建 primary constructor 参数列表
        var constructorParams = properties
            .Select(property => new
            {
                property,
                propertyType =
                    GetFullyQualifiedSnapshotPropertyType(property.Type, snapshotableTypeNames)
            })
            .Select(t => new { t, propertyName = t.property.Name })
            .Select(t => $"{t.t.propertyType} {t.propertyName}").ToList();

        var paramsString = string.Join(", ", constructorParams);
        sb.AppendLine($"    public record {snapshotClassName}({paramsString});");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {className} 的快照扩展方法");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static partial class SnapshotExtensions");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// 创建 {className} 的快照");
        sb.AppendLine("        /// </summary>");

        var fullClassName = classSymbol.ToDisplayString();
        sb.AppendLine($"        public static {namespaceName}.{snapshotClassName} ToSnapshot(this {fullClassName} source)");
        sb.AppendLine("        {");

        // 生成 record 构造函数调用
        sb.Append($"            return new {namespaceName}.{snapshotClassName}(");

        // 生成构造函数参数
        var paramMappings = properties.Select(property =>
        {
            var propertyName = property.Name;
            // 获取不带可空注解的类型全名（用于判断是否是可快照类型）
            var propertyTypeFullName = property.Type.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));
            var isNullable = property.Type.NullableAnnotation == NullableAnnotation.Annotated;

            // 检查属性类型是否是可快照类型
            if (snapshotableTypeNames.Contains(propertyTypeFullName))
            {
                // 如果是可快照类型，调用其ToSnapshot方法
                // 严格模式：根据原始类型的可空性声明决定是否使用 ?. 操作符
                // 不可空类型使用 .ToSnapshot()，可空类型使用 ?.ToSnapshot()
                return isNullable
                    ? $"source.{propertyName}?.ToSnapshot()"
                    : $"source.{propertyName}.ToSnapshot()";
            }

            // 否则直接赋值
            return $"source.{propertyName}";
        }).ToList();

        sb.Append(string.Join(", ", paramMappings));
        sb.AppendLine(");");

        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// 获取类的所有公开属性
    /// </summary>
    private static List<IPropertySymbol> GetPublicProperties(INamedTypeSymbol classSymbol)
    {
        var properties = new List<IPropertySymbol>();

        foreach (var member in classSymbol.GetMembers())
        {
            if (member is not IPropertySymbol { DeclaredAccessibility: Accessibility.Public, IsStatic: false } property)
            {
                continue;
            }
            if (property.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString().EndsWith("SnapshotIgnoreAttribute") == true))
            {
                continue;
            }

            properties.Add(property);
        }

        return properties;
    }

    /// <summary>
    /// 获取完全限定的快照属性类型（如果属性类型是可快照类型，返回其快照类型的完全限定名称）
    /// </summary>
    private static string GetFullyQualifiedSnapshotPropertyType(ITypeSymbol typeSymbol, HashSet<string> snapshotableTypeNames)
    {
        // 获取不带可空注解的类型全名（用于判断是否是可快照类型）
        var typeFullNameWithoutNullable = typeSymbol.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes));

        // 检查原始类型是否可空
        var isNullable = typeSymbol.NullableAnnotation == NullableAnnotation.Annotated;

        // 检查是否是可快照类型
        if (!snapshotableTypeNames.Contains(typeFullNameWithoutNullable.TrimEnd('?')))
        {
            // 不是可快照类型，返回原始类型的完全限定名称（保留可空性）
            return typeSymbol.ToDisplayString();
        }

        // 是可快照类型，需要映射为快照类型
        // 获取类型的命名空间和名称
        var typeNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
        var typeName = typeSymbol.Name;

        // 返回完全限定的快照类型名称，保持原始的可空性
        return isNullable
            ? $"{typeNamespace}.{typeName}Snapshot?"
            : $"{typeNamespace}.{typeName}Snapshot";
    }
}
