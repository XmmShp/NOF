using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;

namespace NOF.Hosting.SourceGenerator;

/// <summary>
/// Source generator: scans all referenced projects and generates ApplicationPart registration code for prefix-matching projects.
/// </summary>
[Generator]
public class ApplicationPartGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get the current project's assembly name and referenced assembly info
        var assemblyInfoProvider = context.CompilationProvider
            .Select(static (compilation, _) =>
            {
                var currentAssemblyName = compilation.AssemblyName ?? string.Empty;

                var matchingAssemblies = new List<AssemblyTypeInfo>();

                // First register the current assembly itself
                var currentType = FindFirstPublicType(compilation.Assembly.GlobalNamespace);
                if (currentType != null)
                {
                    matchingAssemblies.Add(new AssemblyTypeInfo(currentAssemblyName, currentType));
                }

                // Scan all referenced assemblies
                foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    var assemblyName = assembly.Name;

                    // Check if the assembly name starts with the current assembly name (e.g. A matches A.Contract, A.Domain, etc.)
                    if (!string.IsNullOrEmpty(currentAssemblyName) &&
                        assemblyName.StartsWith(currentAssemblyName) &&
                        (assemblyName.Length == currentAssemblyName.Length || assemblyName[currentAssemblyName.Length] == '.'))
                    {
                        // Find a suitable type from this assembly
                        var typeSymbol = FindFirstPublicType(assembly.GlobalNamespace);
                        if (typeSymbol != null)
                        {
                            matchingAssemblies.Add(new AssemblyTypeInfo(assemblyName, typeSymbol));
                        }
                    }
                }

                return (Prefix: currentAssemblyName, Assemblies: matchingAssemblies.ToImmutableArray());
            });

        // Generate code
        context.RegisterSourceOutput(assemblyInfoProvider, static (spc, info) =>
        {
            if (info.Assemblies.IsEmpty)
            {
                return;
            }

            var source = GenerateApplicationPartExtension(info.Prefix, info.Assemblies);
            spc.AddSource("ApplicationPartExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    /// <summary>
    /// Recursively finds the first public, non-abstract class in a namespace.
    /// </summary>
    private static INamedTypeSymbol? FindFirstPublicType(INamespaceSymbol ns)
    {
        foreach (var member in ns.GetMembers())
        {
            switch (member)
            {
                case INamespaceSymbol childNs:
                    var result = FindFirstPublicType(childNs);
                    if (result != null)
                    {
                        return result;
                    }
                    break;

                case INamedTypeSymbol { IsAbstract: false, DeclaredAccessibility: Accessibility.Public } type:
                    // Return the first public non-abstract class found
                    return type;
            }
        }

        return null;
    }

    private static string GenerateApplicationPartExtension(string prefix, ImmutableArray<AssemblyTypeInfo> assemblies)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using NOF.Infrastructure.Core;");
        sb.AppendLine();

        sb.AppendLine($"namespace {prefix}");
        sb.AppendLine("{");

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Auto-generated ApplicationPart registration extension methods (prefix: {prefix}).");
        sb.AppendLine("    /// </summary>");
        var sanitizedPrefix = prefix.Replace(".", "");
        sb.AppendLine($"    public static partial class {sanitizedPrefix}Extensions");
        sb.AppendLine("    {");

        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Auto-registers all referenced projects with prefix '{prefix}' as ApplicationParts.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"builder\">The NOF application builder.</param>");
        sb.AppendLine("        /// <returns>The builder for chaining.</returns>");
        sb.AppendLine("        public static NOF.Infrastructure.Core.INOFAppBuilder WithAutoApplicationParts(this NOF.Infrastructure.Core.INOFAppBuilder builder)");
        sb.AppendLine("        {");

        if (assemblies.Length > 0)
        {
            sb.AppendLine("            // Auto-register the following assemblies:");
            foreach (var assemblyInfo in assemblies)
            {
                sb.AppendLine($"            // - {assemblyInfo.AssemblyName}");
            }
            sb.AppendLine();

            foreach (var assemblyInfo in assemblies)
            {
                var typeFormat = SymbolDisplayFormat.FullyQualifiedFormat
                    .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)
                    .WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

                var typeName = assemblyInfo.TypeSymbol.ToDisplayString(typeFormat);

                sb.AppendLine($"            builder.WithApplicationPart(typeof({typeName}).Assembly!);");
            }
        }

        sb.AppendLine("            return builder;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private readonly struct AssemblyTypeInfo
    {
        public AssemblyTypeInfo(string assemblyName, INamedTypeSymbol typeSymbol)
        {
            AssemblyName = assemblyName;
            TypeSymbol = typeSymbol;
        }

        public string AssemblyName { get; }
        public INamedTypeSymbol TypeSymbol { get; }
    }
}
