using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;

namespace NOF;

/// <summary>
/// 源生成器：自动扫描所有引用的项目，并为前缀匹配的项目生成 ApplicationPart 注册代码
/// </summary>
[Generator]
public class ApplicationPartGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取当前项目的程序集名称和引用的程序集信息
        var assemblyInfoProvider = context.CompilationProvider
            .Select(static (compilation, _) =>
            {
                var currentAssemblyName = compilation.AssemblyName ?? string.Empty;

                var matchingAssemblies = new List<AssemblyTypeInfo>();

                // 首先注册当前程序集自己
                var currentType = FindFirstPublicType(compilation.Assembly.GlobalNamespace);
                if (currentType != null)
                {
                    matchingAssemblies.Add(new AssemblyTypeInfo(currentAssemblyName, currentType));
                }

                // 扫描所有引用的程序集
                foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    var assemblyName = assembly.Name;

                    // 检查程序集名称是否以当前程序集名称开头（例如 A 可以匹配 A.Contract, A.Domain 等）
                    if (!string.IsNullOrEmpty(currentAssemblyName) &&
                        assemblyName.StartsWith(currentAssemblyName) &&
                        (assemblyName.Length == currentAssemblyName.Length || assemblyName[currentAssemblyName.Length] == '.'))
                    {
                        // 从该程序集中查找一个合适的类型
                        var typeSymbol = FindFirstPublicType(assembly.GlobalNamespace);
                        if (typeSymbol != null)
                        {
                            matchingAssemblies.Add(new AssemblyTypeInfo(assemblyName, typeSymbol));
                        }
                    }
                }

                return (Prefix: currentAssemblyName, Assemblies: matchingAssemblies.ToImmutableArray());
            });

        // 生成代码
        context.RegisterSourceOutput(assemblyInfoProvider, static (spc, info) =>
        {
            if (info.Assemblies.IsEmpty)
            {
                return;
            }

            var source = GenerateApplicationPartExtension(info.Prefix, info.Assemblies);
            spc.AddSource("ApplicationPartExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    /// <summary>
    /// 递归查找命名空间中的第一个公共、非抽象类
    /// </summary>
    private static INamedTypeSymbol? FindFirstPublicType(INamespaceSymbol ns)
    {
        foreach (var member in ns.GetMembers())
        {
            switch (member)
            {
                case INamespaceSymbol childNs:
                    var result = FindFirstPublicType(childNs);
                    if (result != null)
                    {
                        return result;
                    }
                    break;

                case INamedTypeSymbol { IsAbstract: false, DeclaredAccessibility: Accessibility.Public } type:
                    // 找到第一个公共非抽象类就返回
                    return type;
            }
        }

        return null;
    }

    private static string GenerateApplicationPartExtension(string prefix, ImmutableArray<AssemblyTypeInfo> assemblies)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine();

        sb.AppendLine("namespace NOF.Generated");
        sb.AppendLine("{");

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// 自动生成的 ApplicationPart 注册扩展方法（前缀: {prefix}）");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class __ApplicationPartExtensions__");
        sb.AppendLine("    {");

        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// 自动注册所有前缀为 '{prefix}' 的引用项目作为 ApplicationPart");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"builder\">NOF 应用构建器</param>");
        sb.AppendLine("        /// <returns>用于链式调用的构建器</returns>");
        sb.AppendLine("        public static NOF.INOFAppBuilder WithAutoApplicationParts(this NOF.INOFAppBuilder builder)");
        sb.AppendLine("        {");

        if (assemblies.Length > 0)
        {
            sb.AppendLine("            // 自动注册以下程序集:");
            foreach (var assemblyInfo in assemblies)
            {
                sb.AppendLine($"            // - {assemblyInfo.AssemblyName}");
            }
            sb.AppendLine();

            foreach (var assemblyInfo in assemblies)
            {
                var typeFormat = SymbolDisplayFormat.FullyQualifiedFormat
                    .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)
                    .WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

                var typeName = assemblyInfo.TypeSymbol.ToDisplayString(typeFormat);

                sb.AppendLine($"            builder.WithApplicationPart(typeof({typeName}).Assembly!);");
            }
        }

        sb.AppendLine("            return builder;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private readonly struct AssemblyTypeInfo
    {
        public AssemblyTypeInfo(string assemblyName, INamedTypeSymbol typeSymbol)
        {
            AssemblyName = assemblyName;
            TypeSymbol = typeSymbol;
        }

        public string AssemblyName { get; }
        public INamedTypeSymbol TypeSymbol { get; }
    }
}
