using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace NOF;

[Generator]
public class ExposeToHttpEndpointMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sourceClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    if (ctx.Node is not TypeDeclarationSyntax tds)
                        return null;
                    if (ctx.SemanticModel.GetDeclaredSymbol(tds) is INamedTypeSymbol { IsAbstract: false, DeclaredAccessibility: Accessibility.Public } symbol
                        && HasExposeToHttpEndpointAttribute(symbol)
                        && IsRequestType(symbol))
                    {
                        return symbol;
                    }
                    return null;
                })
            .Where(static s => s is not null);

        var referencedTypes = context.CompilationProvider
            .Select(static (compilation, _) =>
            {
                var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();
                foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    CollectEndpointTypes(assembly.GlobalNamespace, builder);
                }
                return builder.ToImmutable();
            });

        var allTypes = referencedTypes.Combine(sourceClasses.Collect())
            .Select(static (pair, _) =>
            {
                var (fromRefs, fromSource) = pair;
                var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                foreach (var t in fromRefs)
                    set.Add(t);
                foreach (var t in Enumerable.OfType<INamedTypeSymbol>(fromSource))
                    set.Add(t);
                return set.ToImmutableArray();
            });

        var endpointInfos = context.CompilationProvider.Combine(allTypes)
            .Select(static (pair, _) =>
            {
                var (compilation, types) = pair;
                var list = ImmutableArray.CreateBuilder<EndpointInfo>();
                foreach (var type in types)
                {
                    var attrs = type.GetAttributes()
                        .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

                    foreach (var attr in attrs)
                    {
                        var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(type, attr, compilation);
                        list.Add(info);
                    }
                }
                return list.ToImmutable();
            });

        context.RegisterSourceOutput(endpointInfos, GenerateMapAllHttpEndpointsExtension);
    }

    private static bool HasExposeToHttpEndpointAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr =>
            attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

    private static bool IsRequestType(INamedTypeSymbol typeSymbol)
        => typeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == "NOF.IRequest" ||
            (i.IsGenericType && i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"));

    private static void CollectEndpointTypes(INamespaceSymbol ns, ImmutableArray<INamedTypeSymbol>.Builder builder)
    {
        foreach (var member in ns.GetMembers())
        {
            switch (member)
            {
                case INamedTypeSymbol { DeclaredAccessibility: Accessibility.Public, IsAbstract: false } type
                    when HasExposeToHttpEndpointAttribute(type)
                         && IsRequestType(type):
                    builder.Add(type);
                    break;
                case INamespaceSymbol nestedNs:
                    CollectEndpointTypes(nestedNs, builder);
                    break;
            }
        }
    }

    private static void GenerateMapAllHttpEndpointsExtension(SourceProductionContext context, ImmutableArray<EndpointInfo> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return;
        }

        const string targetNamespace = "NOF.Generated";
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine("{");
        sb.AppendLine("    public static class __WebApplicationExtensions__");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all HTTP endpoints marked with [ExposeToHttpEndpoint].");
        sb.AppendLine("        /// Generated by source generator.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static WebApplication MapAllHttpEndpoints(this WebApplication app)");
        sb.AppendLine("        {");

        foreach (var ep in endpoints)
        {
            EmitEndpointMapping(sb, ep);
        }

        sb.AppendLine("            return app;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("NOF.WebApplicationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitEndpointMapping(StringBuilder sb, EndpointInfo ep)
    {
        var mapMethod = ep.Method switch
        {
            HttpVerb.Get => "MapGet",
            HttpVerb.Post => "MapPost",
            HttpVerb.Put => "MapPut",
            HttpVerb.Delete => "MapDelete",
            HttpVerb.Patch => "MapPatch",
            _ => throw new InvalidOperationException($"Unsupported verb: {ep.Method}")
        };

        var requestType = ep.RequestType.ToDisplayString();
        var isGet = ep.Method == HttpVerb.Get;
        var routeParams = ExtractRouteParameters(ep.Route);
        var hasRouteParams = routeParams.Count > 0;

        // Case 1: GET — always use [AsParameters], minimal API handles route + query binding
        // Case 2: Non-GET, no route params — use [FromBody] directly
        // Case 3: Non-GET, with route params — bind route params individually + optional [FromBody] body + construct request
        if (isGet || !hasRouteParams)
        {
            var fromAttr = isGet ? "[AsParameters]" : "[FromBody]";
            sb.Append($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine();
            sb.AppendLine($"                async ({fromAttr} {requestType} request, [FromServices] NOF.IRequestSender sender) =>");
            sb.AppendLine("                {");
            sb.AppendLine("                    var response = await sender.SendAsync(request);");
            sb.AppendLine("                    return TypedResults.Ok(response);");
            sb.Append("                })");
        }
        else
        {
            // Non-GET with route params: need to split binding
            var allProperties = GetAllPublicProperties(ep.RequestType);

            // Match route params to properties (case-insensitive)
            var routeParamProps = new List<(string RouteParamName, IPropertySymbol Property)>();
            var bodyProps = new List<IPropertySymbol>();

            foreach (var prop in allProperties)
            {
                var matchedParam = routeParams.FirstOrDefault(rp =>
                    string.Equals(rp, prop.Name, StringComparison.OrdinalIgnoreCase));
                if (matchedParam != null)
                {
                    routeParamProps.Add((matchedParam, prop));
                }
                else
                {
                    bodyProps.Add(prop);
                }
            }

            var hasBody = bodyProps.Count > 0;

            // Build lambda parameter list
            var lambdaParams = new List<string>();
            foreach (var (routeParamName, prop) in routeParamProps)
            {
                lambdaParams.Add($"{prop.Type.ToDisplayString()} {ToCamelCase(prop.Name)}");
            }
            if (hasBody)
            {
                lambdaParams.Add($"[FromBody] System.Text.Json.JsonElement __body__");
            }
            lambdaParams.Add("[FromServices] NOF.IRequestSender sender");

            var lambdaParamStr = string.Join(", ", lambdaParams);

            sb.Append($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine();
            sb.AppendLine($"                async ({lambdaParamStr}) =>");
            sb.AppendLine("                {");

            // Deserialize body properties from JsonElement
            if (hasBody)
            {
                sb.AppendLine("                    var __opts__ = System.Text.Json.JsonSerializerOptions.NOFDefaults;");
                foreach (var prop in bodyProps)
                {
                    var propType = prop.Type.ToDisplayString();
                    var bang = NullForgivingSuffix(prop.Type);
                    var camel = ToCamelCase(prop.Name);
                    sb.AppendLine($"                    var __{camel}__ = (__body__.TryGetProperty(\"{prop.Name}\", out var __el_{camel}__) || __body__.TryGetProperty(\"{camel}\", out __el_{camel}__))");
                    sb.AppendLine($"                        ? __el_{camel}__.Deserialize<{propType}>(__opts__){bang}");
                    sb.AppendLine($"                        : default({propType}){bang};");
                }
            }

            // Construct the request object
            // Strategy: find a constructor that can accept all properties, or fall back to parameterless + property setters
            var bestCtor = FindBestConstructor(ep.RequestType, allProperties);

            if (bestCtor != null)
            {
                // Use constructor — map each ctor param to either a route param or a body param
                var ctorArgs = new List<string>();
                foreach (var ctorParam in bestCtor.Parameters)
                {
                    var routeMatch = routeParamProps.FirstOrDefault(rp =>
                        string.Equals(rp.Property.Name, ctorParam.Name, StringComparison.OrdinalIgnoreCase));
                    if (routeMatch.Property != null)
                    {
                        ctorArgs.Add(ToCamelCase(routeMatch.Property.Name));
                    }
                    else
                    {
                        var bodyMatch = bodyProps.FirstOrDefault(bp =>
                            string.Equals(bp.Name, ctorParam.Name, StringComparison.OrdinalIgnoreCase));
                        if (bodyMatch != null)
                        {
                            ctorArgs.Add($"__{ToCamelCase(bodyMatch.Name)}__");
                        }
                        else
                        {
                            ctorArgs.Add($"default");
                        }
                    }
                }
                sb.AppendLine($"                    var request = new {requestType}({string.Join(", ", ctorArgs)});");
            }
            else
            {
                // Parameterless constructor + object initializer (supports both set and init properties)
                var initLines = new List<string>();
                foreach (var (_, prop) in routeParamProps)
                {
                    initLines.Add($"                        {prop.Name} = {ToCamelCase(prop.Name)}");
                }
                foreach (var prop in bodyProps)
                {
                    initLines.Add($"                        {prop.Name} = __{ToCamelCase(prop.Name)}__");
                }
                sb.AppendLine($"                    var request = new {requestType}");
                sb.AppendLine("                    {");
                for (var i = 0; i < initLines.Count; i++)
                {
                    sb.Append(initLines[i]);
                    sb.AppendLine(i < initLines.Count - 1 ? "," : "");
                }
                sb.AppendLine("                    };");
            }

            sb.AppendLine("                    var response = await sender.SendAsync(request);");
            sb.AppendLine("                    return TypedResults.Ok(response);");
            sb.Append("                })");
        }

        // Append OpenAPI metadata
        if (!string.IsNullOrEmpty(ep.DisplayName))
            sb.Append($".WithName(\"{EscapeString(ep.DisplayName)}\")");
        if (!string.IsNullOrEmpty(ep.Summary))
            sb.Append($".WithSummary(\"{EscapeString(ep.Summary)}\")");
        if (!string.IsNullOrEmpty(ep.Description))
            sb.Append($".WithDescription(\"{EscapeString(ep.Description)}\")");
        if (ep.Tags.Length > 0)
        {
            var tagArgs = string.Join(", ", ep.Tags.Select(t => $"\"{EscapeString(t)}\""));
            sb.Append($".WithTags({tagArgs})");
        }

        sb.AppendLine(";");
        sb.AppendLine();
    }

    private static List<string> ExtractRouteParameters(string route)
    {
        var result = new List<string>();
        var matches = Regex.Matches(route, @"\{(\w+)\}");
        foreach (Match match in matches)
        {
            result.Add(match.Groups[1].Value);
        }
        return result;
    }

    private static List<IPropertySymbol> GetAllPublicProperties(INamedTypeSymbol typeSymbol)
    {
        var properties = new List<IPropertySymbol>();
        var seen = new HashSet<string>();
        var current = typeSymbol;
        while (current != null)
        {
            foreach (var member in current.GetMembers())
            {
                if (member is IPropertySymbol { DeclaredAccessibility: Accessibility.Public, IsStatic: false, IsIndexer: false, GetMethod: not null } prop
                    && seen.Add(prop.Name))
                {
                    properties.Add(prop);
                }
            }
            current = current.BaseType;
        }
        return properties;
    }

    /// <summary>
    /// Find a constructor whose parameters match all properties (by name, case-insensitive).
    /// Prefers the constructor with the most parameters (primary ctor for records).
    /// </summary>
    private static IMethodSymbol FindBestConstructor(INamedTypeSymbol typeSymbol, List<IPropertySymbol> allProperties)
    {
        var propNames = new HashSet<string>(allProperties.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);

        return typeSymbol.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public
                        && !c.IsStatic
                        && c.Parameters.Length > 0
                        && c.Parameters.All(p => propNames.Contains(p.Name)))
            .OrderByDescending(c => c.Parameters.Length)
            .FirstOrDefault();
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    /// <summary>
    /// Returns "!" if the type is a non-nullable reference type, otherwise empty string.
    /// This prevents CS8604 warnings when assigning Deserialize results to non-nullable parameters.
    /// </summary>
    private static string NullForgivingSuffix(ITypeSymbol type)
    {
        // Value types (int, long, etc.) don't need null-forgiving
        if (type.IsValueType) return string.Empty;
        // Nullable reference types (string?) don't need it either
        if (type.NullableAnnotation == NullableAnnotation.Annotated) return string.Empty;
        // Non-nullable reference types (string, MyClass) need "!"
        return "!";
    }

    private static string EscapeString(string? value)
    {
        if (value is null) return string.Empty;
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}

#region Helper
internal static class ExposeToHttpEndpointHelpers
{
    public static ITypeSymbol? GetResponseType(INamedTypeSymbol requestType)
    {
        var requestInterface = requestType.AllInterfaces
            .FirstOrDefault(i => i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"
                                 && i.IsGenericType);

        return requestInterface is { TypeArguments.Length: 1 }
            ? requestInterface.TypeArguments[0]
            : null;
    }

    public static EndpointInfo ExtractEndpointInfo(
        INamedTypeSymbol classSymbol,
        AttributeData attr,
        Compilation compilation)
    {
        var method = (HttpVerb)attr.ConstructorArguments[0].Value!;
        var route = attr.ConstructorArguments.Length > 1
            ? attr.ConstructorArguments[1].Value as string
            : null;
        route = route?.TrimEnd('/');

        const string requestSuffix = "Request";
        var operationName = attr.NamedArguments.FirstOrDefault(arg => arg.Key == "OperationName").Value.Value as string
                            ?? (classSymbol.Name.EndsWith(requestSuffix)
                                ? classSymbol.Name.Substring(0, classSymbol.Name.Length - requestSuffix.Length)
                                : classSymbol.Name);

        route ??= operationName;

        var responseType = GetResponseType(classSymbol);

        var allAttrs = classSymbol.GetAttributes();

        var description = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.DescriptionAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var displayName = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.DisplayNameAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var summary = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.SummaryAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var category = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.CategoryAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var tags = !string.IsNullOrWhiteSpace(category)
            ? category!.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(t => t.Trim())
                .Where(t => t.Length > 0)
                .ToArray()
            : Array.Empty<string>();

        return new EndpointInfo
        {
            RequestType = classSymbol,
            ResponseType = responseType,
            Method = method,
            Route = route,
            OperationName = operationName,
            Description = description,
            DisplayName = displayName,
            Summary = summary,
            Tags = tags
        };
    }
}

internal class EndpointInfo
{
    public INamedTypeSymbol RequestType { get; set; } = null!;
    public ITypeSymbol? ResponseType { get; set; }
    public HttpVerb Method { get; set; }
    public string Route { get; set; } = string.Empty;
    public string OperationName { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string? DisplayName { get; set; }
    public string? Summary { get; set; }
    public string[] Tags { get; set; } = Array.Empty<string>();
}

internal enum HttpVerb
{
    Get,
    Post,
    Put,
    Delete,
    Patch
}
#endregion