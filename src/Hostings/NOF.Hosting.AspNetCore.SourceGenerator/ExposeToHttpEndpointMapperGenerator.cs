using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace NOF;

[Generator]
public class ExposeToHttpEndpointMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sourceClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    if (ctx.Node is not TypeDeclarationSyntax tds)
                        return null;
                    if (ctx.SemanticModel.GetDeclaredSymbol(tds) is INamedTypeSymbol { IsAbstract: false, DeclaredAccessibility: Accessibility.Public } symbol
                        && HasExposeToHttpEndpointAttribute(symbol)
                        && IsRequestType(symbol))
                    {
                        return symbol;
                    }
                    return null;
                })
            .Where(static s => s is not null);

        var referencedTypes = context.CompilationProvider
            .Select(static (compilation, _) =>
            {
                var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();
                foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    CollectEndpointTypes(assembly.GlobalNamespace, builder);
                }
                return builder.ToImmutable();
            });

        var allTypes = referencedTypes.Combine(sourceClasses.Collect())
            .Select(static (pair, _) =>
            {
                var (fromRefs, fromSource) = pair;
                var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                foreach (var t in fromRefs)
                    set.Add(t);
                foreach (var t in Enumerable.OfType<INamedTypeSymbol>(fromSource))
                    set.Add(t);
                return set.ToImmutableArray();
            });

        var endpointInfos = context.CompilationProvider.Combine(allTypes)
            .Select(static (pair, _) =>
            {
                var (compilation, types) = pair;
                var list = ImmutableArray.CreateBuilder<EndpointInfo>();
                foreach (var type in types)
                {
                    var attrs = type.GetAttributes()
                        .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

                    foreach (var attr in attrs)
                    {
                        var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(type, attr, compilation);
                        list.Add(info);
                    }
                }
                return list.ToImmutable();
            });

        context.RegisterSourceOutput(endpointInfos, GenerateMapAllHttpEndpointsExtension);
    }

    private static bool HasExposeToHttpEndpointAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr =>
            attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

    private static bool IsRequestType(INamedTypeSymbol typeSymbol)
        => typeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == "NOF.IRequest" ||
            (i.IsGenericType && i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"));

    private static void CollectEndpointTypes(INamespaceSymbol ns, ImmutableArray<INamedTypeSymbol>.Builder builder)
    {
        foreach (var member in ns.GetMembers())
        {
            switch (member)
            {
                case INamedTypeSymbol { DeclaredAccessibility: Accessibility.Public, IsAbstract: false } type
                    when HasExposeToHttpEndpointAttribute(type)
                         && IsRequestType(type):
                    builder.Add(type);
                    break;
                case INamespaceSymbol nestedNs:
                    CollectEndpointTypes(nestedNs, builder);
                    break;
            }
        }
    }

    private static void GenerateMapAllHttpEndpointsExtension(SourceProductionContext context, ImmutableArray<EndpointInfo> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return;
        }

        const string targetNamespace = "NOF.Generated";
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine("{");

        // Generate Body DTO classes for non-GET endpoints with route params that have body properties
        foreach (var ep in endpoints)
        {
            EmitBodyDtoIfNeeded(sb, ep);
        }

        sb.AppendLine("    public static class __WebApplicationExtensions__");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all HTTP endpoints marked with [ExposeToHttpEndpoint].");
        sb.AppendLine("        /// Generated by source generator.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static WebApplication MapAllHttpEndpoints(this WebApplication app)");
        sb.AppendLine("        {");

        foreach (var ep in endpoints)
        {
            EmitEndpointMapping(sb, ep);
        }

        sb.AppendLine("            return app;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("NOF.WebApplicationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitEndpointMapping(StringBuilder sb, EndpointInfo ep)
    {
        var mapMethod = ep.Method switch
        {
            HttpVerb.Get => "MapGet",
            HttpVerb.Post => "MapPost",
            HttpVerb.Put => "MapPut",
            HttpVerb.Delete => "MapDelete",
            HttpVerb.Patch => "MapPatch",
            _ => throw new InvalidOperationException($"Unsupported verb: {ep.Method}")
        };

        var requestType = ep.RequestType.ToDisplayString();
        var isGet = ep.Method == HttpVerb.Get;
        var routeParams = ExtractRouteParameters(ep.Route);
        var hasRouteParams = routeParams.Count > 0;

        // Case 1: GET — always use [AsParameters], minimal API handles route + query binding
        // Case 2: Non-GET, no route params — use [FromBody] directly
        // Case 3: Non-GET, with route params — bind route params individually + optional [FromBody] body DTO + construct request
        if (isGet || !hasRouteParams)
        {
            var fromAttr = isGet ? "[AsParameters]" : "[FromBody]";
            sb.Append($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine();
            sb.AppendLine($"                async ({fromAttr} {requestType} request, [FromServices] NOF.IRequestSender sender) =>");
            sb.AppendLine("                {");
            sb.AppendLine("                    var response = await sender.SendAsync(request);");
            sb.AppendLine("                    return TypedResults.Ok(response);");
            sb.Append("                })");
        }
        else
        {
            // Non-GET with route params: use generated Body DTO for OpenAPI-friendly binding
            var allProperties = GetAllPublicProperties(ep.RequestType);
            var (routeParamProps, bodyProps) = SplitRouteAndBodyProps(allProperties, routeParams);
            var hasBody = bodyProps.Count > 0;
            var bodyDtoName = GetBodyDtoName(ep.RequestType);

            // Build lambda parameter list
            var lambdaParams = new List<string>();
            foreach (var (_, prop) in routeParamProps)
            {
                lambdaParams.Add($"{prop.Type.ToDisplayString()} {ToCamelCase(prop.Name)}");
            }
            if (hasBody)
            {
                lambdaParams.Add($"[FromBody] NOF.Generated.{bodyDtoName} __body__");
            }
            lambdaParams.Add("[FromServices] NOF.IRequestSender sender");

            var lambdaParamStr = string.Join(", ", lambdaParams);

            sb.Append($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine();
            sb.AppendLine($"                async ({lambdaParamStr}) =>");
            sb.AppendLine("                {");

            // Construct the request object
            // Supports three patterns:
            //   1. Record with primary ctor covering all props: new Request(a, b, c)
            //   2. Hybrid: ctor + extra settable props: new Request(a) { B = b, C = c }
            //   3. Parameterless ctor + object initializer: new Request { A = a, B = b }
            var bestCtor = FindBestConstructor(ep.RequestType, allProperties);
            var ctorParamNames = bestCtor != null
                ? new HashSet<string>(bestCtor.Parameters.Select(p => p.Name), StringComparer.OrdinalIgnoreCase)
                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            // Build constructor arguments
            var ctorArgStr = "";
            if (bestCtor != null)
            {
                var ctorArgs = new List<string>();
                foreach (var ctorParam in bestCtor.Parameters)
                {
                    var routeMatch = routeParamProps.FirstOrDefault(rp =>
                        string.Equals(rp.Property.Name, ctorParam.Name, StringComparison.OrdinalIgnoreCase));
                    if (routeMatch.Property != null)
                    {
                        ctorArgs.Add(ToCamelCase(routeMatch.Property.Name));
                    }
                    else
                    {
                        var bodyMatch = bodyProps.FirstOrDefault(bp =>
                            string.Equals(bp.Name, ctorParam.Name, StringComparison.OrdinalIgnoreCase));
                        ctorArgs.Add(bodyMatch != null ? $"__body__.{bodyMatch.Name}" : "default");
                    }
                }
                ctorArgStr = string.Join(", ", ctorArgs);
            }

            // Collect remaining properties not covered by the constructor
            var initLines = new List<string>();
            foreach (var (_, prop) in routeParamProps)
            {
                if (!ctorParamNames.Contains(prop.Name))
                    initLines.Add($"                        {prop.Name} = {ToCamelCase(prop.Name)}");
            }
            foreach (var prop in bodyProps)
            {
                if (!ctorParamNames.Contains(prop.Name))
                    initLines.Add($"                        {prop.Name} = __body__.{prop.Name}");
            }

            // Emit: new RequestType(ctorArgs) { ExtraProp = value, ... };
            if (initLines.Count > 0)
            {
                sb.AppendLine($"                    var request = new {requestType}({ctorArgStr})");
                sb.AppendLine("                    {");
                for (var i = 0; i < initLines.Count; i++)
                {
                    sb.Append(initLines[i]);
                    sb.AppendLine(i < initLines.Count - 1 ? "," : "");
                }
                sb.AppendLine("                    };");
            }
            else
            {
                sb.AppendLine($"                    var request = new {requestType}({ctorArgStr});");
            }

            sb.AppendLine("                    var response = await sender.SendAsync(request);");
            sb.AppendLine("                    return TypedResults.Ok(response);");
            sb.Append("                })");
        }

        // Append OpenAPI metadata
        if (!string.IsNullOrEmpty(ep.DisplayName))
            sb.Append($".WithName(\"{EscapeString(ep.DisplayName)}\")");
        if (!string.IsNullOrEmpty(ep.Summary))
            sb.Append($".WithSummary(\"{EscapeString(ep.Summary)}\")");
        if (!string.IsNullOrEmpty(ep.Description))
            sb.Append($".WithDescription(\"{EscapeString(ep.Description)}\")");
        if (ep.Tags.Length > 0)
        {
            var tagArgs = string.Join(", ", ep.Tags.Select(t => $"\"{EscapeString(t)}\""));
            sb.Append($".WithTags({tagArgs})");
        }

        sb.AppendLine(";");
        sb.AppendLine();
    }

    /// <summary>
    /// Emits a Body DTO class for a non-GET endpoint with route params that has body properties.
    /// The DTO contains only the non-route properties, giving OpenAPI full schema visibility.
    /// </summary>
    private static void EmitBodyDtoIfNeeded(StringBuilder sb, EndpointInfo ep)
    {
        if (ep.Method == HttpVerb.Get) return;

        var routeParams = ExtractRouteParameters(ep.Route);
        if (routeParams.Count == 0) return;

        var allProperties = GetAllPublicProperties(ep.RequestType);
        var (_, bodyProps) = SplitRouteAndBodyProps(allProperties, routeParams);
        if (bodyProps.Count == 0) return;

        var dtoName = GetBodyDtoName(ep.RequestType);
        sb.AppendLine($"    public class {dtoName}");
        sb.AppendLine("    {");
        foreach (var prop in bodyProps)
        {
            var propType = prop.Type.ToDisplayString();
            var defaultValue = prop.Type.IsValueType ? "" : " = default!;";
            if (prop.Type.NullableAnnotation == NullableAnnotation.Annotated)
                defaultValue = "";
            sb.AppendLine($"        public {propType} {prop.Name} {{ get; set; }}{defaultValue}");
        }
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static List<string> ExtractRouteParameters(string route)
    {
        var result = new List<string>();
        var matches = Regex.Matches(route, @"\{(\w+)\}");
        foreach (Match match in matches)
        {
            result.Add(match.Groups[1].Value);
        }
        return result;
    }

    private static List<IPropertySymbol> GetAllPublicProperties(INamedTypeSymbol typeSymbol)
    {
        var properties = new List<IPropertySymbol>();
        var seen = new HashSet<string>();
        var current = typeSymbol;
        while (current != null)
        {
            foreach (var member in current.GetMembers())
            {
                if (member is IPropertySymbol { DeclaredAccessibility: Accessibility.Public, IsStatic: false, IsIndexer: false, GetMethod: not null } prop
                    && seen.Add(prop.Name))
                {
                    properties.Add(prop);
                }
            }
            current = current.BaseType;
        }
        return properties;
    }

    /// <summary>
    /// Find a constructor whose parameters match all properties (by name, case-insensitive).
    /// Prefers the constructor with the most parameters (primary ctor for records).
    /// </summary>
    private static IMethodSymbol FindBestConstructor(INamedTypeSymbol typeSymbol, List<IPropertySymbol> allProperties)
    {
        var propNames = new HashSet<string>(allProperties.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);

        return typeSymbol.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public
                        && !c.IsStatic
                        && c.Parameters.Length > 0
                        && c.Parameters.All(p => propNames.Contains(p.Name)))
            .OrderByDescending(c => c.Parameters.Length)
            .FirstOrDefault();
    }

    private static (List<(string RouteParamName, IPropertySymbol Property)> RouteProps, List<IPropertySymbol> BodyProps)
        SplitRouteAndBodyProps(List<IPropertySymbol> allProperties, List<string> routeParams)
    {
        var routeParamProps = new List<(string RouteParamName, IPropertySymbol Property)>();
        var bodyProps = new List<IPropertySymbol>();

        foreach (var prop in allProperties)
        {
            var matchedParam = routeParams.FirstOrDefault(rp =>
                string.Equals(rp, prop.Name, StringComparison.OrdinalIgnoreCase));
            if (matchedParam != null)
                routeParamProps.Add((matchedParam, prop));
            else
                bodyProps.Add(prop);
        }

        return (routeParamProps, bodyProps);
    }

    private static string GetBodyDtoName(INamedTypeSymbol requestType)
        => $"__{requestType.Name}_Body__";

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string EscapeString(string? value)
    {
        if (value is null) return string.Empty;
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}

#region Helper
internal static class ExposeToHttpEndpointHelpers
{
    public static ITypeSymbol? GetResponseType(INamedTypeSymbol requestType)
    {
        var requestInterface = requestType.AllInterfaces
            .FirstOrDefault(i => i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"
                                 && i.IsGenericType);

        return requestInterface is { TypeArguments.Length: 1 }
            ? requestInterface.TypeArguments[0]
            : null;
    }

    public static EndpointInfo ExtractEndpointInfo(
        INamedTypeSymbol classSymbol,
        AttributeData attr,
        Compilation compilation)
    {
        var method = (HttpVerb)attr.ConstructorArguments[0].Value!;
        var route = attr.ConstructorArguments.Length > 1
            ? attr.ConstructorArguments[1].Value as string
            : null;
        route = route?.TrimEnd('/');

        const string requestSuffix = "Request";
        var operationName = attr.NamedArguments.FirstOrDefault(arg => arg.Key == "OperationName").Value.Value as string
                            ?? (classSymbol.Name.EndsWith(requestSuffix)
                                ? classSymbol.Name.Substring(0, classSymbol.Name.Length - requestSuffix.Length)
                                : classSymbol.Name);

        route ??= operationName;

        var responseType = GetResponseType(classSymbol);

        var allAttrs = classSymbol.GetAttributes();

        var displayName = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.EndpointNameAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var description = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.EndpointDescriptionAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var summary = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.SummaryAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var tags = allAttrs
            .Where(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.CategoryAttribute")
            .Select(a => a.ConstructorArguments.FirstOrDefault().Value as string)
            .Where(v => v != null)
            .ToArray();

        return new EndpointInfo
        {
            RequestType = classSymbol,
            ResponseType = responseType,
            Method = method,
            Route = route,
            OperationName = operationName,
            DisplayName = displayName,
            Description = description,
            Summary = summary,
            Tags = tags!
        };
    }
}

internal class EndpointInfo
{
    public INamedTypeSymbol RequestType { get; set; } = null!;
    public ITypeSymbol? ResponseType { get; set; }
    public HttpVerb Method { get; set; }
    public string Route { get; set; } = string.Empty;
    public string OperationName { get; set; } = string.Empty;
    public string? DisplayName { get; set; }
    public string? Description { get; set; }
    public string? Summary { get; set; }
    public string[] Tags { get; set; } = Array.Empty<string>();
}

internal enum HttpVerb
{
    Get,
    Post,
    Put,
    Delete,
    Patch
}
#endregion
