using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Hosting.AspNetCore.SourceGenerator;

[Generator]
public class ExposeToHttpEndpointMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sourceClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    if (ctx.Node is not TypeDeclarationSyntax tds)
                        return null;
                    if (ctx.SemanticModel.GetDeclaredSymbol(tds) is INamedTypeSymbol { IsAbstract: false, DeclaredAccessibility: Accessibility.Public } symbol
                        && ExposeToHttpEndpointHelpers.HasExposeToHttpEndpointAttribute(symbol)
                        && ExposeToHttpEndpointHelpers.IsRequestType(symbol))
                    {
                        return symbol;
                    }
                    return null;
                })
            .Where(static s => s is not null);

        var referencedTypes = context.CompilationProvider
            .Select(static (compilation, _) =>
            {
                var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();
                foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    CollectEndpointTypes(assembly.GlobalNamespace, builder);
                }
                return builder.ToImmutable();
            });

        var allTypes = referencedTypes.Combine(sourceClasses.Collect())
            .Select(static (pair, _) =>
            {
                var (fromRefs, fromSource) = pair;
                var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                foreach (var t in fromRefs)
                    set.Add(t);
                foreach (var t in Enumerable.OfType<INamedTypeSymbol>(fromSource))
                    set.Add(t);
                return set.ToImmutableArray();
            });

        var endpointInfos = context.CompilationProvider.Combine(allTypes)
            .Select(static (pair, _) =>
            {
                var (compilation, types) = pair;
                var list = ImmutableArray.CreateBuilder<EndpointInfo>();
                foreach (var type in types)
                {
                    var attrs = type.GetAttributes()
                        .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.Contract.ExposeToHttpEndpointAttribute");

                    foreach (var attr in attrs)
                    {
                        var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(type, attr, compilation);
                        list.Add(info);
                    }
                }
                return (AssemblyName: compilation.AssemblyName ?? "Unknown", Endpoints: list.ToImmutable());
            });

        context.RegisterSourceOutput(endpointInfos, static (ctx, data) => GenerateMapAllHttpEndpointsExtension(ctx, data.AssemblyName, data.Endpoints));
    }

    private static void CollectEndpointTypes(INamespaceSymbol ns, ImmutableArray<INamedTypeSymbol>.Builder builder)
    {
        foreach (var member in ns.GetMembers())
        {
            switch (member)
            {
                case INamedTypeSymbol { DeclaredAccessibility: Accessibility.Public, IsAbstract: false } type
                    when ExposeToHttpEndpointHelpers.HasExposeToHttpEndpointAttribute(type)
                         && ExposeToHttpEndpointHelpers.IsRequestType(type):
                    builder.Add(type);
                    break;
                case INamespaceSymbol nestedNs:
                    CollectEndpointTypes(nestedNs, builder);
                    break;
            }
        }
    }

    private static void GenerateMapAllHttpEndpointsExtension(SourceProductionContext context, string assemblyName, ImmutableArray<EndpointInfo> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return;
        }


        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName}");
        sb.AppendLine("{");

        // Generate Body DTO classes for non-GET endpoints with route params that have body properties
        foreach (var ep in endpoints)
        {
            EmitBodyDtoIfNeeded(sb, ep);
        }

        var sanitizedAssemblyName = assemblyName.Replace(".", "");
        sb.AppendLine($"    public static partial class {sanitizedAssemblyName}Extensions");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all HTTP endpoints marked with [ExposeToHttpEndpoint].");
        sb.AppendLine("        /// Generated by source generator.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static global::Microsoft.AspNetCore.Builder.WebApplication MapAllHttpEndpoints(this global::Microsoft.AspNetCore.Builder.WebApplication app)");
        sb.AppendLine("        {");

        foreach (var ep in endpoints)
        {
            EmitEndpointMapping(sb, ep);
        }

        sb.AppendLine("            return app;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("WebApplicationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitEndpointMapping(StringBuilder sb, EndpointInfo ep)
    {
        var mapMethod = ep.Method switch
        {
            HttpVerb.Get => "MapGet",
            HttpVerb.Post => "MapPost",
            HttpVerb.Put => "MapPut",
            HttpVerb.Delete => "MapDelete",
            HttpVerb.Patch => "MapPatch",
            _ => throw new InvalidOperationException($"Unsupported verb: {ep.Method}")
        };

        var requestType = ep.RequestType.ToDisplayString();
        var isGet = ep.Method == HttpVerb.Get;
        var routeParams = ExposeToHttpEndpointHelpers.ExtractRouteParameters(ep.Route);
        var hasRouteParams = routeParams.Count > 0;

        // Case 1: GET — always use [AsParameters], minimal API handles route + query binding
        // Case 2: Non-GET, no route params — use [FromBody] directly
        // Case 3: Non-GET, with route params — bind route params individually + optional [FromBody] body DTO + construct request
        if (isGet || !hasRouteParams)
        {
            var fromAttr = isGet ? "[global::Microsoft.AspNetCore.Http.AsParametersAttribute]" : "[global::Microsoft.AspNetCore.Mvc.FromBodyAttribute]";
            sb.Append($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine();
            sb.AppendLine($"                async ({fromAttr} {requestType} request, [global::Microsoft.AspNetCore.Mvc.FromServicesAttribute] global::NOF.Application.IRequestSender sender) =>");
            sb.AppendLine("                {");
            sb.AppendLine("                    var response = await sender.SendAsync(request);");
            sb.AppendLine("                    return global::Microsoft.AspNetCore.Http.TypedResults.Ok(response);");
            sb.Append("                })");
        }
        else
        {
            // Non-GET with route params: use generated Body DTO for OpenAPI-friendly binding
            var allProperties = ExposeToHttpEndpointHelpers.GetAllPublicProperties(ep.RequestType);
            var (routeParamProps, bodyProps) = SplitRouteAndBodyProps(allProperties, routeParams);
            var hasBody = bodyProps.Count > 0;
            var bodyDtoName = GetBodyDtoName(ep.RequestType);

            // Build lambda parameter list
            var lambdaParams = new List<string>();
            foreach (var (_, prop) in routeParamProps)
            {
                lambdaParams.Add($"{prop.Type.ToDisplayString()} {ToCamelCase(prop.Name)}");
            }
            if (hasBody)
            {
                lambdaParams.Add($"[global::Microsoft.AspNetCore.Mvc.FromBodyAttribute] {bodyDtoName} __body__");
            }
            lambdaParams.Add("[global::Microsoft.AspNetCore.Mvc.FromServicesAttribute] global::NOF.Application.IRequestSender sender");

            var lambdaParamStr = string.Join(", ", lambdaParams);

            sb.Append($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine();
            sb.AppendLine($"                async ({lambdaParamStr}) =>");
            sb.AppendLine("                {");

            // Construct the request object
            // Supports three patterns:
            //   1. Record with primary ctor covering all props: new Request(a, b, c)
            //   2. Hybrid: ctor + extra settable props: new Request(a) { B = b, C = c }
            //   3. Parameterless ctor + object initializer: new Request { A = a, B = b }
            var bestCtor = FindBestConstructor(ep.RequestType, allProperties);
            var ctorParamNames = bestCtor != null
                ? new HashSet<string>(bestCtor.Parameters.Select(p => p.Name), StringComparer.OrdinalIgnoreCase)
                : new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            // Build constructor arguments
            var ctorArgStr = "";
            if (bestCtor != null)
            {
                var ctorArgs = new List<string>();
                foreach (var ctorParam in bestCtor.Parameters)
                {
                    var routeMatch = routeParamProps.FirstOrDefault(rp =>
                        string.Equals(rp.Property.Name, ctorParam.Name, StringComparison.OrdinalIgnoreCase));
                    if (routeMatch.Property != null)
                    {
                        ctorArgs.Add(ToCamelCase(routeMatch.Property.Name));
                    }
                    else
                    {
                        var bodyMatch = bodyProps.FirstOrDefault(bp =>
                            string.Equals(bp.Name, ctorParam.Name, StringComparison.OrdinalIgnoreCase));
                        ctorArgs.Add(bodyMatch != null ? $"__body__.{bodyMatch.Name}" : "default");
                    }
                }
                ctorArgStr = string.Join(", ", ctorArgs);
            }

            // Collect remaining properties not covered by the constructor
            var initLines = new List<string>();
            foreach (var (_, prop) in routeParamProps)
            {
                if (!ctorParamNames.Contains(prop.Name))
                    initLines.Add($"                        {prop.Name} = {ToCamelCase(prop.Name)}");
            }
            foreach (var prop in bodyProps)
            {
                if (!ctorParamNames.Contains(prop.Name))
                    initLines.Add($"                        {prop.Name} = __body__.{prop.Name}");
            }

            // Emit: new RequestType(ctorArgs) { ExtraProp = value, ... };
            if (initLines.Count > 0)
            {
                sb.AppendLine($"                    var request = new {requestType}({ctorArgStr})");
                sb.AppendLine("                    {");
                for (var i = 0; i < initLines.Count; i++)
                {
                    sb.Append(initLines[i]);
                    sb.AppendLine(i < initLines.Count - 1 ? "," : "");
                }
                sb.AppendLine("                    };");
            }
            else
            {
                sb.AppendLine($"                    var request = new {requestType}({ctorArgStr});");
            }

            sb.AppendLine("                    var response = await sender.SendAsync(request);");
            sb.AppendLine("                    return global::Microsoft.AspNetCore.Http.TypedResults.Ok(response);");
            sb.Append("                })");
        }

        // Append OpenAPI metadata
        if (!string.IsNullOrEmpty(ep.DisplayName))
            sb.Append($".WithName(\"{EscapeString(ep.DisplayName)}\")");
        if (!string.IsNullOrEmpty(ep.Summary))
            sb.Append($".WithSummary(\"{EscapeString(ep.Summary)}\")");
        if (!string.IsNullOrEmpty(ep.Description))
            sb.Append($".WithDescription(\"{EscapeString(ep.Description)}\")");
        if (ep.Tags.Length > 0)
        {
            var tagArgs = string.Join(", ", ep.Tags.Select(t => $"\"{EscapeString(t)}\""));
            sb.Append($".WithTags({tagArgs})");
        }

        sb.AppendLine(";");
        sb.AppendLine();
    }

    /// <summary>
    /// Emits a Body DTO class for a non-GET endpoint with route params that has body properties.
    /// The DTO contains only the non-route properties, giving OpenAPI full schema visibility.
    /// </summary>
    private static void EmitBodyDtoIfNeeded(StringBuilder sb, EndpointInfo ep)
    {
        if (ep.Method == HttpVerb.Get)
            return;

        var routeParams = ExposeToHttpEndpointHelpers.ExtractRouteParameters(ep.Route);
        if (routeParams.Count == 0)
            return;

        var allProperties = ExposeToHttpEndpointHelpers.GetAllPublicProperties(ep.RequestType);
        var (_, bodyProps) = SplitRouteAndBodyProps(allProperties, routeParams);
        if (bodyProps.Count == 0)
            return;

        var dtoName = GetBodyDtoName(ep.RequestType);
        sb.AppendLine($"    public class {dtoName}");
        sb.AppendLine("    {");
        foreach (var prop in bodyProps)
        {
            var propType = prop.Type.ToDisplayString();
            var defaultValue = prop.Type.IsValueType ? "" : " = default!;";
            if (prop.Type.NullableAnnotation == NullableAnnotation.Annotated)
                defaultValue = "";
            sb.AppendLine($"        public {propType} {prop.Name} {{ get; set; }}{defaultValue}");
        }
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Find a constructor whose parameters match all properties (by name, case-insensitive).
    /// Prefers the constructor with the most parameters (primary ctor for records).
    /// </summary>
    private static IMethodSymbol FindBestConstructor(INamedTypeSymbol typeSymbol, List<IPropertySymbol> allProperties)
    {
        var propNames = new HashSet<string>(allProperties.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);

        return typeSymbol.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public
                        && !c.IsStatic
                        && c.Parameters.Length > 0
                        && c.Parameters.All(p => propNames.Contains(p.Name)))
            .OrderByDescending(c => c.Parameters.Length)
            .FirstOrDefault();
    }

    private static (List<(string RouteParamName, IPropertySymbol Property)> RouteProps, List<IPropertySymbol> BodyProps)
        SplitRouteAndBodyProps(List<IPropertySymbol> allProperties, List<string> routeParams)
    {
        var routeParamProps = new List<(string RouteParamName, IPropertySymbol Property)>();
        var bodyProps = new List<IPropertySymbol>();

        foreach (var prop in allProperties)
        {
            var matchedParam = routeParams.FirstOrDefault(rp =>
                string.Equals(rp, prop.Name, StringComparison.OrdinalIgnoreCase));
            if (matchedParam != null)
                routeParamProps.Add((matchedParam, prop));
            else
                bodyProps.Add(prop);
        }

        return (routeParamProps, bodyProps);
    }

    private static string GetBodyDtoName(INamedTypeSymbol requestType)
        => $"__{requestType.Name}_Body__";

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string EscapeString(string? value)
    {
        if (value is null)
            return string.Empty;
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}
