using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Infrastructure.SourceGenerator;

[Generator]
public class ExposeToHttpEndpointMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sourceClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    if (ctx.Node is not TypeDeclarationSyntax tds)
                        return null;
                    if (ctx.SemanticModel.GetDeclaredSymbol(tds) is INamedTypeSymbol { IsAbstract: false, DeclaredAccessibility: Accessibility.Public } symbol
                        && HasExposeToHttpEndpointAttribute(symbol)
                        && IsRequestType(symbol))
                    {
                        return symbol;
                    }
                    return null;
                })
            .Where(static s => s is not null);

        var referencedTypes = context.CompilationProvider
            .Select(static (compilation, _) =>
            {
                var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();
                foreach (var assembly in compilation.SourceModule.ReferencedAssemblySymbols)
                {
                    CollectEndpointTypes(assembly.GlobalNamespace, builder);
                }
                return builder.ToImmutable();
            });

        var allTypes = referencedTypes.Combine(sourceClasses.Collect())
            .Select(static (pair, _) =>
            {
                var (fromRefs, fromSource) = pair;
                var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                foreach (var t in fromRefs)
                    set.Add(t);
                foreach (var t in Enumerable.OfType<INamedTypeSymbol>(fromSource))
                    set.Add(t);
                return set.ToImmutableArray();
            });

        var endpointInfos = context.CompilationProvider.Combine(allTypes)
            .Select(static (pair, _) =>
            {
                var (compilation, types) = pair;
                var list = ImmutableArray.CreateBuilder<EndpointInfo>();
                foreach (var type in types)
                {
                    var attrs = type.GetAttributes()
                        .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

                    foreach (var attr in attrs)
                    {
                        var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(type, attr, compilation);
                        list.Add(info);
                    }
                }
                return list.ToImmutable();
            });

        context.RegisterSourceOutput(endpointInfos, GenerateMapAllHttpEndpointsExtension);
    }

    private static bool HasExposeToHttpEndpointAttribute(INamedTypeSymbol symbol)
        => symbol.GetAttributes().Any(attr =>
            attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

    private static bool IsRequestType(INamedTypeSymbol typeSymbol)
        => typeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == "NOF.IRequest" ||
            (i.IsGenericType && i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"));

    private static void CollectEndpointTypes(INamespaceSymbol ns, ImmutableArray<INamedTypeSymbol>.Builder builder)
    {
        foreach (var member in ns.GetMembers())
        {
            switch (member)
            {
                case INamedTypeSymbol { DeclaredAccessibility: Accessibility.Public, IsAbstract: false } type
                    when HasExposeToHttpEndpointAttribute(type)
                         && IsRequestType(type):
                    builder.Add(type);
                    break;
                case INamespaceSymbol nestedNs:
                    CollectEndpointTypes(nestedNs, builder);
                    break;
            }
        }
    }

    private static void GenerateMapAllHttpEndpointsExtension(SourceProductionContext context, ImmutableArray<EndpointInfo> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return;
        }

        const string targetNamespace = "NOF.Generated";
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using MassTransit.Mediator;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine("{");
        sb.AppendLine("    public static class __WebApplicationExtensions__");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all HTTP endpoints marked with [ExposeToHttpEndpoint].");
        sb.AppendLine("        /// Generated by source generator.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static WebApplication MapAllHttpEndpoints(this WebApplication app)");
        sb.AppendLine("        {");

        foreach (var ep in endpoints)
        {
            var mapMethod = ep.Method switch
            {
                HttpVerb.Get => "MapGet",
                HttpVerb.Post => "MapPost",
                HttpVerb.Put => "MapPut",
                HttpVerb.Delete => "MapDelete",
                HttpVerb.Patch => "MapPatch",
                _ => throw new InvalidOperationException($"Unsupported verb: {ep.Method}")
            };

            var fromAttr = ep.Method == HttpVerb.Get ? "[FromQuery]" : "[FromBody]";
            var requestType = ep.RequestType.ToDisplayString();

            // Build the lambda
            sb.AppendLine($"            app.{mapMethod}(\"{ep.Route}\",");
            sb.AppendLine($"                async ({fromAttr} {requestType} request, [FromServices] IScopedMediator mediator) =>");
            sb.AppendLine("                {");
            sb.AppendLine("                    var response = await mediator.SendRequest(request);");
            sb.AppendLine("                    return Results.Ok(response);");
            sb.AppendLine("                })");

            // Apply metadata
            if (ep.AllowAnonymous)
            {
                sb.AppendLine("                .AllowAnonymous()");
            }

            if (!string.IsNullOrEmpty(ep.Permission))
            {
                sb.AppendLine($"                .RequirePermission(\"{ep.Permission}\")");
            }

            sb.AppendLine("                ;");
            sb.AppendLine();
        }

        sb.AppendLine("            return app;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("NOF.WebApplicationExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}

#region Helper
internal static class ExposeToHttpEndpointHelpers
{
    public static ITypeSymbol? GetResponseType(INamedTypeSymbol requestType)
    {
        var requestInterface = requestType.AllInterfaces
            .FirstOrDefault(i => i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"
                                 && i.IsGenericType);

        return requestInterface is { TypeArguments.Length: 1 }
            ? requestInterface.TypeArguments[0]
            : null;
    }

    public static EndpointInfo ExtractEndpointInfo(
        INamedTypeSymbol classSymbol,
        AttributeData attr,
        Compilation compilation)
    {
        var method = (HttpVerb)attr.ConstructorArguments[0].Value!;
        var route = attr.ConstructorArguments.Length > 1
            ? attr.ConstructorArguments[1].Value as string
            : null;
        route = route?.TrimEnd('/');

        const string requestSuffix = "Request";
        var operationName = attr.NamedArguments.FirstOrDefault(arg => arg.Key == "OperationName").Value.Value as string
                            ?? (classSymbol.Name.EndsWith(requestSuffix)
                                ? classSymbol.Name.Substring(0, classSymbol.Name.Length - requestSuffix.Length)
                                : classSymbol.Name);

        route ??= operationName;

        var responseType = GetResponseType(classSymbol);
        var permission = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "Permission").Value.Value as string;
        var allowAnonymous = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "AllowAnonymous").Value.Value is true;

        return new EndpointInfo
        {
            RequestType = classSymbol,
            ResponseType = responseType,
            Method = method,
            Route = route,
            OperationName = operationName,
            Permission = permission,
            AllowAnonymous = allowAnonymous
        };
    }
}

internal class EndpointInfo
{
    public INamedTypeSymbol RequestType { get; set; } = null!;
    public ITypeSymbol? ResponseType { get; set; }
    public HttpVerb Method { get; set; }
    public string Route { get; set; } = string.Empty;
    public string OperationName { get; set; } = string.Empty;
    public string? Permission { get; set; }
    public bool AllowAnonymous { get; set; }
}

internal enum HttpVerb
{
    Get,
    Post,
    Put,
    Delete,
    Patch
}
#endregion