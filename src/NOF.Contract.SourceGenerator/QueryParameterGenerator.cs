using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Contract.SourceGenerator;

/// <summary>
/// 源生成器：检测标记了QueryParameterAttribute的类，并生成ToQueryString扩展方法
/// </summary>
[Generator]
public class QueryParameterGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取所有带有QueryParameterAttribute的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // 将语法和语义模型组合起来
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // 注册源代码输出
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    /// <summary>
    /// 判断语法节点是否是我们要处理的目标
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // 处理类、记录和结构体声明
        return node is TypeDeclarationSyntax typeDeclaration
            // 确保类型有特性列表
            && typeDeclaration.AttributeLists.Count > 0;
    }

    /// <summary>
    /// 获取语义模型中的目标类型
    /// </summary>
    private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        // 获取类型声明语法节点（类、记录或结构体）
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        // 获取类型的符号信息
        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);
        if (typeSymbol is null)
        {
            return null;
        }

        // 检查类型是否标记了QueryParameterAttribute
        var hasAttribute = typeSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString() == "NOF.QueryParameterAttribute");

        return hasAttribute ? typeDeclaration : null;
    }

    /// <summary>
    /// 生成源代码
    /// </summary>
    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax?> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        var typesToGenerate = Enumerable.OfType<TypeDeclarationSyntax>(types)
            .Select(typeDeclaration => new
            {
                TypeDeclaration = typeDeclaration,
                SemanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree)
            })
            .Select(typeContext => typeContext
                .SemanticModel
                .GetDeclaredSymbol(typeContext.TypeDeclaration)
            )
            .OfType<INamedTypeSymbol>()
            .Select(typeSymbol =>
            (
                typeSymbol.ToDisplayString(),
                GetAllProperties(typeSymbol)
                    .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                    .ToList()
            ))
            .ToList();

        if (typesToGenerate.Count <= 0)
        {
            return;
        }
        var source = GenerateExtensionMethodsFile(typesToGenerate);
        context.AddSource("QueryParameterExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    /// <summary>
    /// 生成扩展方法文件
    /// </summary>
    private static string GenerateExtensionMethodsFile(List<(string TypeName, List<IPropertySymbol> Properties)> typesToGenerate)
    {
        var sb = new StringBuilder();

        // 添加必要的命名空间引用
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine();

        // 生成命名空间
        sb.AppendLine("namespace NOF");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// 查询参数扩展方法");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class __QueryParameterExtensions__");
        sb.AppendLine("    {");

        // 为每个类型生成扩展方法
        foreach (var (typeName, properties) in typesToGenerate)
        {
            GenerateExtensionMethod(sb, typeName, properties);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// 生成单个扩展方法
    /// </summary>
    private static void GenerateExtensionMethod(StringBuilder sb, string typeName, List<IPropertySymbol> properties)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// 将{typeName}对象转换为URL查询字符串");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        /// <param name=\"source\">要转换的{typeName}对象</param>");
        sb.AppendLine("        /// <returns>URL查询字符串，如果有参数则以?开头</returns>");
        sb.AppendLine($"        public static string ToQueryString(this {typeName} source)");
        sb.AppendLine("        {");
        sb.AppendLine("            var queryParams = new Dictionary<string, string?>();");
        sb.AppendLine();

        // 为每个属性生成查询参数代码
        foreach (var property in properties)
        {
            var propertyName = property.Name;
            var isNullable = property.NullableAnnotation == NullableAnnotation.Annotated;
            var propertyAccess = isNullable
                ? $"source.{propertyName}?.ToString()"
                : $"source.{propertyName}.ToString()";

            sb.AppendLine($"            queryParams[\"{propertyName}\"] = {propertyAccess};");
        }

        // 生成查询字符串
        sb.AppendLine();
        sb.AppendLine("            var queryStringParts = new List<string>();");
        sb.AppendLine("            foreach (var param in queryParams)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (string.IsNullOrEmpty(param.Value))");
        sb.AppendLine("                {");
        sb.AppendLine("                    continue;");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                var escapedKey = Uri.EscapeDataString(param.Key);");
        sb.AppendLine("                var escapedValue = Uri.EscapeDataString(param.Value);");
        sb.AppendLine("                queryStringParts.Add($\"{escapedKey}={escapedValue}\");");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            return queryStringParts.Count > 0 ? \"?\" + string.Join(\"&\", queryStringParts) : string.Empty;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    /// <summary>
    /// 获取类型的所有属性，包括继承的属性
    /// </summary>
    private static IEnumerable<IPropertySymbol> GetAllProperties(ISymbol classSymbol)
    {
        if (classSymbol is not INamedTypeSymbol currentType)
        {
            yield break;
        }

        var allProperties = new Dictionary<string, IPropertySymbol>();

        var baseTypes = new List<INamedTypeSymbol>();
        var type = currentType;

        while (type is not null && type.SpecialType != SpecialType.System_Object)
        {
            baseTypes.Add(type);
            type = type.BaseType;
        }

        baseTypes.Reverse();
        foreach (var member in baseTypes.SelectMany(namedType => namedType.GetMembers().Where(m => m.Kind == SymbolKind.Property)))
        {
            if (member is IPropertySymbol property)
            {
                allProperties[property.Name] = property;
            }
        }

        foreach (var property in allProperties.Values)
        {
            yield return property;
        }
    }
}
