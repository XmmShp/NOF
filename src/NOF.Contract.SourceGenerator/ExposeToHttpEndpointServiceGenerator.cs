using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace NOF.Contract.SourceGenerator;

[Generator]
public class ExposeToHttpEndpointServiceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetEligibleType(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilationAndClasses, GenerateClients);
    }

    private static INamedTypeSymbol? GetEligibleType(GeneratorSyntaxContext ctx)
    {
        var node = (TypeDeclarationSyntax)ctx.Node;
        var model = ctx.SemanticModel;

        if (model.GetDeclaredSymbol(node) is not { } symbol
            || !ExposeToHttpEndpointHelpers.HasExposeToHttpEndpointAttribute(symbol)
            || !ExposeToHttpEndpointHelpers.IsRequestType(symbol))
        {
            return null;
        }

        return symbol;
    }

    private static void GenerateClients(SourceProductionContext context, (Compilation Compilation, ImmutableArray<INamedTypeSymbol?> Classes) source)
    {
        if (source.Classes.IsDefaultOrEmpty)
        {
            return;
        }

        var endpointsByNamespace = new Dictionary<string, List<EndpointInfo>>();

        foreach (var classSymbol in source.Classes.Distinct(SymbolEqualityComparer.Default).OfType<INamedTypeSymbol>())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var attributes = classSymbol.GetAttributes()
                .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

            var rootNamespace = ExposeToHttpEndpointHelpers.GetRootNamespace(classSymbol.ContainingNamespace);
            if (string.IsNullOrEmpty(rootNamespace))
                continue;

            if (!endpointsByNamespace.TryGetValue(rootNamespace!, out var list))
            {
                list = [];
                endpointsByNamespace[rootNamespace!] = list;
            }

            foreach (var attr in attributes)
            {
                var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(classSymbol, attr, source.Compilation);
                list.Add(info);
            }
        }

        foreach (var kv in endpointsByNamespace)
        {
            var ns = kv.Key;
            var endpoints = kv.Value;
            GenerateClientForNamespace(context, ns, endpoints.ToArray());
        }
    }

    private static void GenerateClientForNamespace(SourceProductionContext context, string namespaceName, EndpointInfo[] endpoints)
    {
        if (endpoints.Length == 0)
        {
            return;
        }

        const string service = "Service";
        var serviceName = namespaceName.EndsWith(service) ? namespaceName : $"{namespaceName}Service";
        var interfaceName = $"I{serviceName}";
        var clientName = $"{serviceName}Client";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using System.Net.Http.Json;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using NOF;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {namespaceName} service client interface");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial interface {interfaceName}");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            var requestType = endpoint.RequestType.ToDisplayString();
            var responseType = endpoint.ResponseType?.ToDisplayString();
            var returnType = string.IsNullOrEmpty(responseType) ? "NOF.Result" : $"NOF.Result<{responseType}>";
            var methodName = endpoint.OperationName;

            sb.AppendLine("        /// <summary>");
            if (!string.IsNullOrEmpty(endpoint.DisplayName))
                sb.AppendLine($"        /// {EscapeXmlComment(endpoint.DisplayName)}");
            else
                sb.AppendLine($"        /// Calls {endpoint.Route} endpoint");
            if (!string.IsNullOrEmpty(endpoint.Summary))
                sb.AppendLine($"        /// <para>{EscapeXmlComment(endpoint.Summary)}</para>");
            if (!string.IsNullOrEmpty(endpoint.Description))
                sb.AppendLine($"        /// <para>{EscapeXmlComment(endpoint.Description)}</para>");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"request\">Request parameters</param>");
            sb.AppendLine("        /// <param name=\"completionOption\">When the operation should complete</param>");
            sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token</param>");
            sb.AppendLine($"        Task<{returnType}> {methodName}Async({requestType} request, HttpCompletionOption completionOption = default, CancellationToken cancellationToken = default);");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {namespaceName} service client implementation");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial class {clientName} : {interfaceName}");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly HttpClient _httpClient;");
        sb.AppendLine("        private static readonly JsonSerializerOptions _jsonOptions = JsonSerializerOptions.NOFDefaults;");
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Initializes a new instance of {clientName}");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"httpClient\">HTTP client</param>");
        sb.AppendLine($"        public {clientName}(HttpClient httpClient)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(httpClient);");
        sb.AppendLine("            _httpClient = httpClient;");
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var endpoint in endpoints)
        {
            EmitMethodBody(sb, endpoint);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{serviceName}Client.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitMethodBody(StringBuilder sb, EndpointInfo endpoint)
    {
        var requestType = endpoint.RequestType.ToDisplayString();
        var responseType = endpoint.ResponseType?.ToDisplayString();
        var returnType = string.IsNullOrEmpty(responseType) ? "NOF.Result" : $"NOF.Result<{responseType}>";
        var methodName = endpoint.OperationName;
        var httpMethod = GetHttpMethod(endpoint.Method);
        var isBodyMethod = IsBodyMethod(endpoint.Method);

        var allProperties = GetAllPublicProperties(endpoint.RequestType);
        var routeParams = ExtractRouteParameters(endpoint.Route);

        var routeParamProperties = new List<(string ParamName, IPropertySymbol Property)>();
        var nonRouteProperties = new List<IPropertySymbol>();

        foreach (var prop in allProperties)
        {
            var matchedParam = routeParams.FirstOrDefault(rp =>
                string.Equals(rp, prop.Name, StringComparison.OrdinalIgnoreCase));
            if (matchedParam != null)
            {
                routeParamProperties.Add((matchedParam, prop));
            }
            else
            {
                nonRouteProperties.Add(prop);
            }
        }

        var hasRouteParams = routeParamProperties.Count > 0;

        sb.AppendLine("        /// <inheritdoc />");
        sb.AppendLine($"        public async Task<{returnType}> {methodName}Async({requestType} request, HttpCompletionOption completionOption, CancellationToken cancellationToken)");
        sb.AppendLine("        {");

        // Step 1: Build the endpoint URL
        if (hasRouteParams)
        {
            // Build route string with parameters replaced
            var routeExpression = BuildRouteInterpolation(endpoint.Route, routeParamProperties);
            sb.AppendLine($"            var endpoint = {routeExpression};");
        }
        else
        {
            sb.AppendLine($"            var endpoint = \"{endpoint.Route}\";");
        }

        // Step 2: Build the request message
        if (isBodyMethod)
        {
            // POST/PUT/PATCH: body method
            if (hasRouteParams && nonRouteProperties.Count > 0)
            {
                // Build a dictionary with only non-route properties for the body
                sb.AppendLine($"            var body = new Dictionary<string, object?>({nonRouteProperties.Count});");
                foreach (var prop in nonRouteProperties)
                {
                    sb.AppendLine($"            body[\"{prop.Name}\"] = request.{prop.Name};");
                }
                sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
                sb.AppendLine("            httpRequest.Content = JsonContent.Create(body, options: _jsonOptions);");
            }
            else if (hasRouteParams && nonRouteProperties.Count == 0)
            {
                // All properties are route params, no body needed
                sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
            }
            else
            {
                // No route params, serialize the whole request as body
                sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
                sb.AppendLine($"            httpRequest.Content = JsonContent.Create(request, typeof({requestType}), options: _jsonOptions);");
            }
        }
        else
        {
            // GET/DELETE: query string method
            if (nonRouteProperties.Count > 0)
            {
                sb.AppendLine("            var queryParts = new List<string>();");
                foreach (var prop in nonRouteProperties)
                {
                    EmitQueryParamAppend(sb, prop);
                }
                sb.AppendLine("            if (queryParts.Count > 0)");
                sb.AppendLine("            {");
                sb.AppendLine("                endpoint = endpoint + \"?\" + string.Join(\"&\", queryParts);");
                sb.AppendLine("            }");
            }
            sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
        }

        // Step 3: Send and parse response
        sb.AppendLine("            using var response = await _httpClient.SendAsync(httpRequest, completionOption, cancellationToken).ConfigureAwait(false);");
        sb.AppendLine("            if (!response.IsSuccessStatusCode)");
        sb.AppendLine("            {");
        sb.AppendLine("                return NOF.Result.Fail((int)response.StatusCode, $\"{(int)response.StatusCode}: {response.ReasonPhrase}\");");
        sb.AppendLine("            }");
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (string.IsNullOrEmpty(responseType))
        {
            sb.AppendLine("                var apiResponse = await response.Content.ReadFromJsonAsync<NOF.Result>(_jsonOptions, cancellationToken: cancellationToken);");
            sb.AppendLine("                return apiResponse ?? NOF.Result.Fail(500, \"Unexpected null response from server.\");");
        }
        else
        {
            sb.AppendLine($"                var apiResponse = await response.Content.ReadFromJsonAsync<NOF.Result<{responseType}>>(_jsonOptions, cancellationToken: cancellationToken);");
            sb.AppendLine("                return apiResponse ?? NOF.Result.Fail(500, \"Unexpected null response from server.\");");
        }

        sb.AppendLine("            }");
        sb.AppendLine("            catch (JsonException ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                return NOF.Result.Fail(400, $\"Response deserialization failed: {ex.Message}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitQueryParamAppend(StringBuilder sb, IPropertySymbol prop)
    {
        var propName = prop.Name;
        var isNullable = prop.Type.NullableAnnotation == NullableAnnotation.Annotated
                         || prop.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

        if (isNullable)
        {
            sb.AppendLine($"            if (request.{propName} is not null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                queryParts.Add(Uri.EscapeDataString(\"{propName}\") + \"=\" + Uri.EscapeDataString({FormatValueExpression($"request.{propName}", prop.Type, true)}));");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            queryParts.Add(Uri.EscapeDataString(\"{propName}\") + \"=\" + Uri.EscapeDataString({FormatValueExpression($"request.{propName}", prop.Type, false)}));");
        }
    }

    private static string FormatValueExpression(string accessor, ITypeSymbol type, bool isNullable)
    {
        var underlying = type;
        var isNullableValueType = false;
        if (isNullable && type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            underlying = namedType.TypeArguments[0];
            isNullableValueType = true;
        }

        var display = underlying.ToDisplayString();
        var valueAccessor = isNullableValueType ? $"{accessor}.Value" : accessor;

        return display switch
        {
            "System.DateTime" => $"{valueAccessor}.ToString(\"O\", CultureInfo.InvariantCulture)",
            "System.DateTimeOffset" => $"{valueAccessor}.ToString(\"O\", CultureInfo.InvariantCulture)",
            "System.DateOnly" => $"{valueAccessor}.ToString(\"yyyy-MM-dd\", CultureInfo.InvariantCulture)",
            "System.TimeOnly" => $"{valueAccessor}.ToString(\"HH:mm:ss.FFFFFFF\", CultureInfo.InvariantCulture)",
            "string" => isNullable ? $"{accessor}!" : accessor,
            _ => $"{accessor}.ToString()!"
        };
    }

    private static List<string> ExtractRouteParameters(string route)
    {
        var result = new List<string>();
        var matches = Regex.Matches(route, @"\{(\w+)\}");
        foreach (Match match in matches)
        {
            result.Add(match.Groups[1].Value);
        }
        return result;
    }

    private static string BuildRouteInterpolation(string route, List<(string ParamName, IPropertySymbol Property)> routeParamProperties)
    {
        var result = route;
        foreach (var (paramName, prop) in routeParamProperties)
        {
            var pattern = "{" + paramName + "}";
            var valueExpr = FormatValueExpression($"request.{prop.Name}", prop.Type, false);
            var replacement = $"{{Uri.EscapeDataString({valueExpr})}}";
            // Case-insensitive replace of the route parameter placeholder
            var idx = result.IndexOf(pattern, StringComparison.OrdinalIgnoreCase);
            if (idx >= 0)
            {
                result = result.Substring(0, idx) + replacement + result.Substring(idx + pattern.Length);
            }
        }
        return "$\"" + result + "\"";
    }

    private static List<IPropertySymbol> GetAllPublicProperties(INamedTypeSymbol typeSymbol)
    {
        var properties = new List<IPropertySymbol>();
        var seen = new HashSet<string>();
        var current = typeSymbol;
        while (current != null)
        {
            foreach (var member in current.GetMembers())
            {
                if (member is IPropertySymbol { DeclaredAccessibility: Accessibility.Public, IsStatic: false, IsIndexer: false, GetMethod: not null } prop
                    && seen.Add(prop.Name))
                {
                    properties.Add(prop);
                }
            }
            current = current.BaseType;
        }
        return properties;
    }

    private static string GetHttpMethod(HttpVerb verb) => verb switch
    {
        HttpVerb.Get => "HttpMethod.Get",
        HttpVerb.Post => "HttpMethod.Post",
        HttpVerb.Put => "HttpMethod.Put",
        HttpVerb.Delete => "HttpMethod.Delete",
        HttpVerb.Patch => "HttpMethod.Patch",
        _ => throw new ArgumentOutOfRangeException(nameof(verb), verb, null)
    };

    private static bool IsBodyMethod(HttpVerb verb) =>
        verb == HttpVerb.Post || verb == HttpVerb.Put || verb == HttpVerb.Patch;

    private static string EscapeXmlComment(string? value)
    {
        if (value is null)
            return string.Empty;
        return value.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }
}

#region Helper
internal static class ExposeToHttpEndpointHelpers
{
    public static bool HasExposeToHttpEndpointAttribute(INamedTypeSymbol symbol)
    {
        return symbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");
    }

    public static bool IsRequestType(INamedTypeSymbol typeSymbol)
    {
        return typeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == "NOF.IRequest"
            || (i is { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.None }
                && i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"));
    }

    public static string? GetRootNamespace(INamespaceSymbol ns)
    {
        while (ns is not null && !string.IsNullOrEmpty(ns.Name))
        {
            if (ns.ContainingNamespace is null || string.IsNullOrEmpty(ns.ContainingNamespace.Name))
            {
                return ns.Name;
            }
            ns = ns.ContainingNamespace;
        }
        return null;
    }

    public static ITypeSymbol? GetResponseType(INamedTypeSymbol requestType)
    {
        var requestInterface = requestType.AllInterfaces
            .FirstOrDefault(i => i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"
                                 && i.IsGenericType);

        return requestInterface is { TypeArguments.Length: 1 }
            ? requestInterface.TypeArguments[0]
            : null;
    }

    public static EndpointInfo ExtractEndpointInfo(
        INamedTypeSymbol classSymbol,
        AttributeData attr,
        Compilation compilation)
    {
        var method = (HttpVerb)attr.ConstructorArguments[0].Value!;
        var route = attr.ConstructorArguments.Length > 1
            ? attr.ConstructorArguments[1].Value as string
            : null;
        route = route?.TrimEnd('/');

        const string requestSuffix = "Request";
        var operationName = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "OperationName").Value.Value as string
            ?? (classSymbol.Name.EndsWith(requestSuffix)
                ? classSymbol.Name.Substring(0, classSymbol.Name.Length - requestSuffix.Length)
                : classSymbol.Name);

        route ??= operationName;

        var responseType = GetResponseType(classSymbol);
        var permission = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "Permission").Value.Value as string;
        var allowAnonymous = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "AllowAnonymous").Value.Value is true;

        var allAttrs = classSymbol.GetAttributes();

        var displayName = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.EndpointNameAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var description = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.EndpointDescriptionAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var summary = allAttrs
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "NOF.SummaryAttribute")
            ?.ConstructorArguments.FirstOrDefault().Value as string;

        var tags = allAttrs
            .Where(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.CategoryAttribute")
            .Select(a => a.ConstructorArguments.FirstOrDefault().Value as string)
            .Where(v => v != null)
            .ToArray();

        return new EndpointInfo
        {
            RequestType = classSymbol,
            ResponseType = responseType,
            Method = method,
            Route = route,
            OperationName = operationName,
            DisplayName = displayName,
            Permission = permission,
            AllowAnonymous = allowAnonymous,
            Description = description,
            Summary = summary,
            Tags = tags!
        };
    }
}

internal class EndpointInfo
{
    public INamedTypeSymbol RequestType { get; set; } = null!;
    public ITypeSymbol? ResponseType { get; set; }
    public HttpVerb Method { get; set; }
    public string Route { get; set; } = string.Empty;
    public string OperationName { get; set; } = string.Empty;
    public string? DisplayName { get; set; }
    public string? Permission { get; set; }
    public bool AllowAnonymous { get; set; }
    public string? Description { get; set; }
    public string? Summary { get; set; }
    public string[] Tags { get; set; } = System.Array.Empty<string>();
}

internal enum HttpVerb
{
    Get,
    Post,
    Put,
    Delete,
    Patch
}
#endregion
