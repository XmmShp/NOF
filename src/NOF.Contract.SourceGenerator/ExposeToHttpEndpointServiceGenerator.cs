using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Contract.SourceGenerator;

[Generator]
public class ExposeToHttpEndpointServiceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetEligibleType(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilationAndClasses, GenerateClients);
    }

    private static INamedTypeSymbol? GetEligibleType(GeneratorSyntaxContext ctx)
    {
        var node = (TypeDeclarationSyntax)ctx.Node;
        var model = ctx.SemanticModel;

        if (model.GetDeclaredSymbol(node) is not { } symbol
            || !ExposeToHttpEndpointHelpers.HasExposeToHttpEndpointAttribute(symbol)
            || !ExposeToHttpEndpointHelpers.IsRequestType(symbol))
        {
            return null;
        }

        return symbol;
    }

    private static void GenerateClients(SourceProductionContext context, (Compilation Compilation, ImmutableArray<INamedTypeSymbol?> Classes) source)
    {
        if (source.Classes.IsDefaultOrEmpty)
        {
            return;
        }

        var endpointsByNamespace = new Dictionary<string, List<EndpointInfo>>();

        foreach (var classSymbol in source.Classes.Distinct(SymbolEqualityComparer.Default).OfType<INamedTypeSymbol>())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var attributes = classSymbol.GetAttributes()
                .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.Contract.ExposeToHttpEndpointAttribute");

            var fullNamespace = classSymbol.ContainingNamespace?.ToDisplayString();
            if (string.IsNullOrEmpty(fullNamespace))
                continue;

            if (!endpointsByNamespace.TryGetValue(fullNamespace!, out var list))
            {
                list = [];
                endpointsByNamespace[fullNamespace!] = list;
            }

            foreach (var attr in attributes)
            {
                var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(classSymbol, attr, source.Compilation);
                list.Add(info);
            }
        }

        foreach (var kv in endpointsByNamespace)
        {
            var ns = kv.Key;
            var endpoints = kv.Value;
            GenerateClientForNamespace(context, ns, endpoints.ToArray());
        }
    }

    private static void GenerateClientForNamespace(SourceProductionContext context, string namespaceName, EndpointInfo[] endpoints)
    {
        if (endpoints.Length == 0)
        {
            return;
        }

        var firstEndpoint = endpoints[0];
        var rootNamespace = ExposeToHttpEndpointHelpers.GetRootNamespace(firstEndpoint.RequestType.ContainingNamespace);
        if (string.IsNullOrEmpty(rootNamespace))
            return;

        var (serviceName, interfaceName, clientName) = ExposeToHttpEndpointHelpers.GetServiceNames(rootNamespace!);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using System.Net.Http.Json;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using NOF.Contract;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {namespaceName} service client interface");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial interface {interfaceName}");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            var requestType = endpoint.RequestType.ToDisplayString();
            var responseType = endpoint.ResponseType?.ToDisplayString();
            var returnType = string.IsNullOrEmpty(responseType) ? "NOF.Contract.Result" : $"NOF.Contract.Result<{responseType}>";
            var methodName = endpoint.OperationName;

            sb.AppendLine("        /// <summary>");
            sb.AppendLine(!string.IsNullOrEmpty(endpoint.DisplayName)
                ? $"        /// {EscapeXmlComment(endpoint.DisplayName)}"
                : $"        /// Calls {endpoint.Route} endpoint");
            if (!string.IsNullOrEmpty(endpoint.Summary))
                sb.AppendLine($"        /// <para>{EscapeXmlComment(endpoint.Summary)}</para>");
            if (!string.IsNullOrEmpty(endpoint.Description))
                sb.AppendLine($"        /// <para>{EscapeXmlComment(endpoint.Description)}</para>");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"request\">Request parameters</param>");
            sb.AppendLine("        /// <param name=\"completionOption\">When the operation should complete</param>");
            sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token</param>");
            sb.AppendLine($"        Task<{returnType}> {methodName}Async({requestType} request, HttpCompletionOption completionOption = default, CancellationToken cancellationToken = default);");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {namespaceName} service client implementation");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial class {clientName} : {interfaceName}");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly HttpClient _httpClient;");
        sb.AppendLine("        private static readonly JsonSerializerOptions _jsonOptions = JsonSerializerOptions.NOFDefaults;");
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Initializes a new instance of {clientName}");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"httpClient\">HTTP client</param>");
        sb.AppendLine($"        public {clientName}(HttpClient httpClient)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(httpClient);");
        sb.AppendLine("            _httpClient = httpClient;");
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var endpoint in endpoints)
        {
            EmitMethodBody(sb, endpoint);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{namespaceName}.{serviceName}Client.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitMethodBody(StringBuilder sb, EndpointInfo endpoint)
    {
        var requestType = endpoint.RequestType.ToDisplayString();
        var responseType = endpoint.ResponseType?.ToDisplayString();
        var returnType = string.IsNullOrEmpty(responseType) ? "NOF.Contract.Result" : $"NOF.Contract.Result<{responseType}>";
        var methodName = endpoint.OperationName;
        var httpMethod = GetHttpMethod(endpoint.Method);
        var isBodyMethod = IsBodyMethod(endpoint.Method);

        var allProperties = ExposeToHttpEndpointHelpers.GetAllPublicProperties(endpoint.RequestType);
        var routeParams = ExposeToHttpEndpointHelpers.ExtractRouteParameters(endpoint.Route);

        var routeParamProperties = new List<(string ParamName, IPropertySymbol Property)>();
        var nonRouteProperties = new List<IPropertySymbol>();

        foreach (var prop in allProperties)
        {
            var matchedParam = routeParams.FirstOrDefault(rp =>
                string.Equals(rp, prop.Name, StringComparison.OrdinalIgnoreCase));
            if (matchedParam != null)
            {
                routeParamProperties.Add((matchedParam, prop));
            }
            else
            {
                nonRouteProperties.Add(prop);
            }
        }

        var hasRouteParams = routeParamProperties.Count > 0;

        sb.AppendLine("        /// <inheritdoc />");
        sb.AppendLine($"        public async Task<{returnType}> {methodName}Async({requestType} request, HttpCompletionOption completionOption, CancellationToken cancellationToken)");
        sb.AppendLine("        {");

        // Step 1: Build the endpoint URL
        if (hasRouteParams)
        {
            // Build route string with parameters replaced
            var routeExpression = BuildRouteInterpolation(endpoint.Route, routeParamProperties);
            sb.AppendLine($"            var endpoint = {routeExpression};");
        }
        else
        {
            sb.AppendLine($"            var endpoint = \"{endpoint.Route}\";");
        }

        // Step 2: Build the request message
        if (isBodyMethod)
        {
            // POST/PUT/PATCH: body method
            if (hasRouteParams && nonRouteProperties.Count > 0)
            {
                // Build a dictionary with only non-route properties for the body
                sb.AppendLine($"            var body = new Dictionary<string, object?>({nonRouteProperties.Count});");
                foreach (var prop in nonRouteProperties)
                {
                    sb.AppendLine($"            body[\"{prop.Name}\"] = request.{prop.Name};");
                }
                sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
                sb.AppendLine("            httpRequest.Content = JsonContent.Create(body, options: _jsonOptions);");
            }
            else if (hasRouteParams && nonRouteProperties.Count == 0)
            {
                // All properties are route params, no body needed
                sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
            }
            else
            {
                // No route params, serialize the whole request as body
                sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
                sb.AppendLine($"            httpRequest.Content = JsonContent.Create(request, typeof({requestType}), options: _jsonOptions);");
            }
        }
        else
        {
            // GET/DELETE: query string method
            if (nonRouteProperties.Count > 0)
            {
                sb.AppendLine("            var queryParts = new List<string>();");
                foreach (var prop in nonRouteProperties)
                {
                    EmitQueryParamAppend(sb, prop);
                }
                sb.AppendLine("            if (queryParts.Count > 0)");
                sb.AppendLine("            {");
                sb.AppendLine("                endpoint = endpoint + \"?\" + string.Join(\"&\", queryParts);");
                sb.AppendLine("            }");
            }
            sb.AppendLine("            using var httpRequest = new HttpRequestMessage(" + httpMethod + ", endpoint);");
        }

        // Step 3: Send and parse response
        sb.AppendLine("            using var response = await _httpClient.SendAsync(httpRequest, completionOption, cancellationToken).ConfigureAwait(false);");
        sb.AppendLine("            if (!response.IsSuccessStatusCode)");
        sb.AppendLine("            {");
        sb.AppendLine("                return NOF.Contract.Result.Fail((int)response.StatusCode, $\"{(int)response.StatusCode}: {response.ReasonPhrase}\");");
        sb.AppendLine("            }");
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (string.IsNullOrEmpty(responseType))
        {
            sb.AppendLine("                var apiResponse = await response.Content.ReadFromJsonAsync<NOF.Contract.Result>(_jsonOptions, cancellationToken: cancellationToken);");
            sb.AppendLine("                return apiResponse ?? NOF.Contract.Result.Fail(500, \"Unexpected null response from server.\");");
        }
        else
        {
            sb.AppendLine($"                var apiResponse = await response.Content.ReadFromJsonAsync<NOF.Contract.Result<{responseType}>>(_jsonOptions, cancellationToken: cancellationToken);");
            sb.AppendLine("                return apiResponse ?? NOF.Contract.Result.Fail(500, \"Unexpected null response from server.\");");
        }

        sb.AppendLine("            }");
        sb.AppendLine("            catch (JsonException ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                return NOF.Contract.Result.Fail(400, $\"Response deserialization failed: {ex.Message}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitQueryParamAppend(StringBuilder sb, IPropertySymbol prop)
    {
        var propName = prop.Name;
        var isNullable = prop.Type.NullableAnnotation == NullableAnnotation.Annotated
                         || prop.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

        if (isNullable)
        {
            sb.AppendLine($"            if (request.{propName} is not null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                queryParts.Add(Uri.EscapeDataString(\"{propName}\") + \"=\" + Uri.EscapeDataString({FormatValueExpression($"request.{propName}", prop.Type, true)}));");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            queryParts.Add(Uri.EscapeDataString(\"{propName}\") + \"=\" + Uri.EscapeDataString({FormatValueExpression($"request.{propName}", prop.Type, false)}));");
        }
    }

    private static string FormatValueExpression(string accessor, ITypeSymbol type, bool isNullable)
    {
        var underlying = type;
        var isNullableValueType = false;
        if (isNullable && type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            underlying = namedType.TypeArguments[0];
            isNullableValueType = true;
        }

        var display = underlying.ToDisplayString();
        var valueAccessor = isNullableValueType ? $"{accessor}.Value" : accessor;

        return display switch
        {
            "System.DateTime" => $"{valueAccessor}.ToString(\"O\", CultureInfo.InvariantCulture)",
            "System.DateTimeOffset" => $"{valueAccessor}.ToString(\"O\", CultureInfo.InvariantCulture)",
            "System.DateOnly" => $"{valueAccessor}.ToString(\"yyyy-MM-dd\", CultureInfo.InvariantCulture)",
            "System.TimeOnly" => $"{valueAccessor}.ToString(\"HH:mm:ss.FFFFFFF\", CultureInfo.InvariantCulture)",
            "string" => isNullable ? $"{accessor}!" : accessor,
            _ => $"{accessor}.ToString()!"
        };
    }

    private static string BuildRouteInterpolation(string route, List<(string ParamName, IPropertySymbol Property)> routeParamProperties)
    {
        var result = route;
        foreach (var (paramName, prop) in routeParamProperties)
        {
            var pattern = "{" + paramName + "}";
            var valueExpr = FormatValueExpression($"request.{prop.Name}", prop.Type, false);
            var replacement = $"{{Uri.EscapeDataString({valueExpr})}}";
            // Case-insensitive replace of the route parameter placeholder
            var idx = result.IndexOf(pattern, StringComparison.OrdinalIgnoreCase);
            if (idx >= 0)
            {
                result = result.Substring(0, idx) + replacement + result.Substring(idx + pattern.Length);
            }
        }
        return "$\"" + result + "\"";
    }

    private static string GetHttpMethod(HttpVerb verb) => verb switch
    {
        HttpVerb.Get => "HttpMethod.Get",
        HttpVerb.Post => "HttpMethod.Post",
        HttpVerb.Put => "HttpMethod.Put",
        HttpVerb.Delete => "HttpMethod.Delete",
        HttpVerb.Patch => "HttpMethod.Patch",
        _ => throw new ArgumentOutOfRangeException(nameof(verb), verb, null)
    };

    private static bool IsBodyMethod(HttpVerb verb) =>
        verb == HttpVerb.Post || verb == HttpVerb.Put || verb == HttpVerb.Patch;

    private static string EscapeXmlComment(string? value)
    {
        if (value is null)
            return string.Empty;
        return value.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }
}
