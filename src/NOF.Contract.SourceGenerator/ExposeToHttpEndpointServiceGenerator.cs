using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Contract.SourceGenerator;

[Generator]
public class ExposeToHttpEndpointServiceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetEligibleType(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilationAndClasses, GenerateClients);
    }

    private static INamedTypeSymbol? GetEligibleType(GeneratorSyntaxContext ctx)
    {
        var node = (TypeDeclarationSyntax)ctx.Node;
        var model = ctx.SemanticModel;

        if (model.GetDeclaredSymbol(node) is not { } symbol
            || !ExposeToHttpEndpointHelpers.HasExposeToHttpEndpointAttribute(symbol)
            || !ExposeToHttpEndpointHelpers.IsRequestType(symbol))
        {
            return null;
        }

        return symbol;
    }

    private static void GenerateClients(SourceProductionContext context, (Compilation Compilation, ImmutableArray<INamedTypeSymbol?> Classes) source)
    {
        if (source.Classes.IsDefaultOrEmpty)
        {
            return;
        }

        var endpoints = new List<EndpointInfo>();

        foreach (var classSymbol in source.Classes.Distinct(SymbolEqualityComparer.Default).OfType<INamedTypeSymbol>())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var attributes = classSymbol.GetAttributes()
                .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.Contract.ExposeToHttpEndpointAttribute");

            foreach (var attr in attributes)
            {
                var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(classSymbol, attr, source.Compilation);
                endpoints.Add(info);
            }
        }

        if (endpoints.Count == 0)
        {
            return;
        }

        var assemblyName = source.Compilation.AssemblyName ?? "Unknown";
        GenerateClientForAssembly(context, assemblyName, endpoints.ToArray());
    }

    private static void GenerateClientForAssembly(SourceProductionContext context, string assemblyName, EndpointInfo[] endpoints)
    {
        if (endpoints.Length == 0)
        {
            return;
        }

        var (serviceName, interfaceName, clientName) = ExposeToHttpEndpointHelpers.GetServiceNames(assemblyName);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using NOF.Contract;");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {assemblyName} service client interface");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial interface {interfaceName}");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            var requestType = endpoint.RequestType.ToDisplayString();
            var responseType = endpoint.ResponseType?.ToDisplayString();
            var returnType = string.IsNullOrEmpty(responseType) ? "global::NOF.Contract.Result" : $"global::NOF.Contract.Result<{responseType}>";
            var methodName = endpoint.OperationName;

            sb.AppendLine("        /// <summary>");
            sb.AppendLine(!string.IsNullOrEmpty(endpoint.DisplayName)
                ? $"        /// {EscapeXmlComment(endpoint.DisplayName)}"
                : $"        /// Calls {endpoint.Route} endpoint");
            if (!string.IsNullOrEmpty(endpoint.Summary))
            {
                sb.AppendLine($"        /// <para>{EscapeXmlComment(endpoint.Summary)}</para>");
            }

            if (!string.IsNullOrEmpty(endpoint.Description))
            {
                sb.AppendLine($"        /// <para>{EscapeXmlComment(endpoint.Description)}</para>");
            }

            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"request\">Request parameters</param>");
            sb.AppendLine("        /// <param name=\"completionOption\">When the operation should complete</param>");
            sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token</param>");
            sb.AppendLine($"        global::System.Threading.Tasks.Task<{returnType}> {methodName}Async({requestType} request, global::System.Net.Http.HttpCompletionOption completionOption = default, global::System.Threading.CancellationToken cancellationToken = default);");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {assemblyName} service client implementation");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial class {clientName} : {interfaceName}");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly global::System.Net.Http.HttpClient _httpClient;");
        sb.AppendLine("        private static readonly global::System.Text.Json.JsonSerializerOptions _jsonOptions = global::System.Text.Json.JsonSerializerOptions.NOFDefaults;");
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Initializes a new instance of {clientName}");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"httpClient\">HTTP client</param>");
        sb.AppendLine($"        public {clientName}(global::System.Net.Http.HttpClient httpClient)");
        sb.AppendLine("        {");
        sb.AppendLine("            global::System.ArgumentNullException.ThrowIfNull(httpClient);");
        sb.AppendLine("            _httpClient = httpClient;");
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var endpoint in endpoints)
        {
            EmitMethodBody(sb, endpoint);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{assemblyName}.{serviceName}Client.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitMethodBody(StringBuilder sb, EndpointInfo endpoint)
    {
        var requestType = endpoint.RequestType.ToDisplayString();
        var responseType = endpoint.ResponseType?.ToDisplayString();
        var returnType = string.IsNullOrEmpty(responseType) ? "global::NOF.Contract.Result" : $"global::NOF.Contract.Result<{responseType}>";
        var methodName = endpoint.OperationName;
        var httpMethod = GetHttpMethod(endpoint.Method);
        var isBodyMethod = IsBodyMethod(endpoint.Method);
        var fqnHttpMethod = $"global::System.Net.Http.{httpMethod}";

        var allProperties = ExposeToHttpEndpointHelpers.GetAllPublicProperties(endpoint.RequestType);
        var routeParams = ExposeToHttpEndpointHelpers.ExtractRouteParameters(endpoint.Route);

        var routeParamProperties = new List<(string ParamName, IPropertySymbol Property)>();
        var nonRouteProperties = new List<IPropertySymbol>();

        foreach (var prop in allProperties)
        {
            var matchedParam = routeParams.FirstOrDefault(rp =>
                string.Equals(rp, prop.Name, StringComparison.OrdinalIgnoreCase));
            if (matchedParam != null)
            {
                routeParamProperties.Add((matchedParam, prop));
            }
            else
            {
                nonRouteProperties.Add(prop);
            }
        }

        var hasRouteParams = routeParamProperties.Count > 0;

        sb.AppendLine("        /// <inheritdoc />");
        sb.AppendLine($"        public async global::System.Threading.Tasks.Task<{returnType}> {methodName}Async({requestType} request, global::System.Net.Http.HttpCompletionOption completionOption, global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("        {");

        // Step 1: Build the endpoint URL
        if (hasRouteParams)
        {
            // Build route string with parameters replaced
            var routeExpression = BuildRouteInterpolation(sb, endpoint.Route, routeParamProperties);
            sb.AppendLine($"            var endpoint = {routeExpression};");
        }
        else
        {
            sb.AppendLine($"            var endpoint = \"{endpoint.Route}\";");
        }

        // Step 2: Build the request message
        if (isBodyMethod)
        {
            // POST/PUT/PATCH: body method
            if (hasRouteParams && nonRouteProperties.Count > 0)
            {
                // Build a dictionary with only non-route properties for the body
                sb.AppendLine($"            var body = new global::System.Collections.Generic.Dictionary<string, object?>({nonRouteProperties.Count});");
                foreach (var prop in nonRouteProperties)
                {
                    sb.AppendLine($"            body[\"{prop.Name}\"] = request.{prop.Name};");
                }
                sb.AppendLine("            using var httpRequest = new global::System.Net.Http.HttpRequestMessage(" + fqnHttpMethod + ", endpoint);");
                sb.AppendLine("            httpRequest.Content = global::System.Net.Http.Json.JsonContent.Create(body, options: _jsonOptions);");
            }
            else if (hasRouteParams && nonRouteProperties.Count == 0)
            {
                // All properties are route params, no body needed
                sb.AppendLine("            using var httpRequest = new global::System.Net.Http.HttpRequestMessage(" + fqnHttpMethod + ", endpoint);");
            }
            else
            {
                // No route params, serialize the whole request as body
                sb.AppendLine("            using var httpRequest = new global::System.Net.Http.HttpRequestMessage(" + fqnHttpMethod + ", endpoint);");
                sb.AppendLine($"            httpRequest.Content = global::System.Net.Http.Json.JsonContent.Create(request, typeof({requestType}), options: _jsonOptions);");
            }
        }
        else
        {
            // GET/DELETE: query string method
            if (nonRouteProperties.Count > 0)
            {
                sb.AppendLine("            var queryParts = new global::System.Collections.Generic.List<string>();");
                foreach (var prop in nonRouteProperties)
                {
                    EmitQueryParamAppend(sb, prop);
                }
                sb.AppendLine("            if (queryParts.Count > 0)");
                sb.AppendLine("            {");
                sb.AppendLine("                endpoint = endpoint + \"?\" + string.Join(\"&\", queryParts);");
                sb.AppendLine("            }");
            }
            sb.AppendLine("            using var httpRequest = new global::System.Net.Http.HttpRequestMessage(" + fqnHttpMethod + ", endpoint);");
        }

        // Step 3: Send and parse response
        sb.AppendLine("            using var response = await _httpClient.SendAsync(httpRequest, completionOption, cancellationToken).ConfigureAwait(false);");
        sb.AppendLine("            if (!response.IsSuccessStatusCode)");
        sb.AppendLine("            {");
        sb.AppendLine("                return global::NOF.Contract.Result.Fail((int)response.StatusCode, $\"{(int)response.StatusCode}: {response.ReasonPhrase}\");");
        sb.AppendLine("            }");
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        if (string.IsNullOrEmpty(responseType))
        {
            sb.AppendLine("                var apiResponse = await global::System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsync<global::NOF.Contract.Result>(response.Content, _jsonOptions, cancellationToken);");
            sb.AppendLine("                return apiResponse ?? global::NOF.Contract.Result.Fail(500, \"Unexpected null response from server.\");");
        }
        else
        {
            sb.AppendLine($"                var apiResponse = await global::System.Net.Http.Json.HttpContentJsonExtensions.ReadFromJsonAsync<global::NOF.Contract.Result<{responseType}>>(response.Content, _jsonOptions, cancellationToken);");
            sb.AppendLine("                return apiResponse ?? global::NOF.Contract.Result.Fail(500, \"Unexpected null response from server.\");");
        }

        sb.AppendLine("            }");
        sb.AppendLine("            catch (global::System.Text.Json.JsonException ex)");
        sb.AppendLine("            {");
        sb.AppendLine("                return global::NOF.Contract.Result.Fail(400, $\"Response deserialization failed: {ex.Message}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitQueryParamAppend(StringBuilder sb, IPropertySymbol prop)
    {
        var propName = prop.Name;
        var isNullable = prop.Type.NullableAnnotation == NullableAnnotation.Annotated
                         || prop.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

        if (isNullable)
        {
            sb.AppendLine($"            if (request.{propName} is not null)");
            sb.AppendLine("            {");
            sb.AppendLine($"                queryParts.Add(global::System.Uri.EscapeDataString(\"{propName}\") + \"=\" + global::System.Uri.EscapeDataString({FormatValueExpression($"request.{propName}", prop.Type, true)}));");
            sb.AppendLine("            }");
        }
        else
        {
            sb.AppendLine($"            queryParts.Add(global::System.Uri.EscapeDataString(\"{propName}\") + \"=\" + global::System.Uri.EscapeDataString({FormatValueExpression($"request.{propName}", prop.Type, false)}));");
        }
    }

    private static string FormatValueExpression(string accessor, ITypeSymbol type, bool isNullable)
    {
        var underlying = type;
        var isNullableValueType = false;
        if (isNullable && type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            underlying = namedType.TypeArguments[0];
            isNullableValueType = true;
        }

        var display = underlying.ToDisplayString();
        var valueAccessor = isNullableValueType ? $"{accessor}.Value" : accessor;

        return display switch
        {
            "System.DateTime" => $"{valueAccessor}.ToString(\"O\", global::System.Globalization.CultureInfo.InvariantCulture)",
            "System.DateTimeOffset" => $"{valueAccessor}.ToString(\"O\", global::System.Globalization.CultureInfo.InvariantCulture)",
            "System.DateOnly" => $"{valueAccessor}.ToString(\"yyyy-MM-dd\", global::System.Globalization.CultureInfo.InvariantCulture)",
            "System.TimeOnly" => $"{valueAccessor}.ToString(\"HH:mm:ss.FFFFFFF\", global::System.Globalization.CultureInfo.InvariantCulture)",
            "string" => isNullable ? $"{accessor}!" : accessor,
            _ => $"{accessor}.ToString()!"
        };
    }

    /// <summary>
    /// Emits local variable declarations for route parameters and returns the interpolated route string.
    /// Uses local variables to avoid global:: inside string interpolation expressions.
    /// </summary>
    private static string BuildRouteInterpolation(StringBuilder sb, string route, List<(string ParamName, IPropertySymbol Property)> routeParamProperties)
    {
        var result = route;
        foreach (var (paramName, prop) in routeParamProperties)
        {
            var localVarName = $"__route_{paramName}__";
            var valueExpr = FormatValueExpression($"request.{prop.Name}", prop.Type, false);
            sb.AppendLine($"            var {localVarName} = global::System.Uri.EscapeDataString({valueExpr});");

            var pattern = "{" + paramName + "}";
            var replacement = $"{{{localVarName}}}";
            var idx = result.IndexOf(pattern, StringComparison.OrdinalIgnoreCase);
            if (idx >= 0)
            {
                result = result.Substring(0, idx) + replacement + result.Substring(idx + pattern.Length);
            }
        }
        return "$\"" + result + "\"";
    }

    private static string GetHttpMethod(HttpVerb verb) => verb switch
    {
        HttpVerb.Get => "HttpMethod.Get",
        HttpVerb.Post => "HttpMethod.Post",
        HttpVerb.Put => "HttpMethod.Put",
        HttpVerb.Delete => "HttpMethod.Delete",
        HttpVerb.Patch => "HttpMethod.Patch",
        _ => throw new ArgumentOutOfRangeException(nameof(verb), verb, null)
    };

    private static bool IsBodyMethod(HttpVerb verb) =>
        verb == HttpVerb.Post || verb == HttpVerb.Put || verb == HttpVerb.Patch;

    private static string EscapeXmlComment(string? value)
    {
        if (value is null)
        {
            return string.Empty;
        }

        return value.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }
}
