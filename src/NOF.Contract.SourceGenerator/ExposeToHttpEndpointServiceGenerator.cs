using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF.Contract.SourceGenerator;

[Generator]
public class ExposeToHttpEndpointServiceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => GetEligibleType(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilationAndClasses, GenerateClients);
    }

    private static INamedTypeSymbol? GetEligibleType(GeneratorSyntaxContext ctx)
    {
        var node = (TypeDeclarationSyntax)ctx.Node;
        var model = ctx.SemanticModel;

        if (model.GetDeclaredSymbol(node) is not { } symbol
            || !ExposeToHttpEndpointHelpers.HasExposeToHttpEndpointAttribute(symbol)
            || !ExposeToHttpEndpointHelpers.IsRequestType(symbol))
        {
            return null;
        }

        return symbol;
    }

    private static void GenerateClients(SourceProductionContext context, (Compilation Compilation, ImmutableArray<INamedTypeSymbol?> Classes) source)
    {
        if (source.Classes.IsDefaultOrEmpty)
        {
            return;
        }

        var endpointsByNamespace = new Dictionary<string, List<EndpointInfo>>();

        foreach (var classSymbol in source.Classes.Distinct(SymbolEqualityComparer.Default).OfType<INamedTypeSymbol>())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var attributes = classSymbol.GetAttributes()
                .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");

            var rootNamespace = ExposeToHttpEndpointHelpers.GetRootNamespace(classSymbol.ContainingNamespace);
            if (string.IsNullOrEmpty(rootNamespace))
                continue;

            if (!endpointsByNamespace.TryGetValue(rootNamespace!, out var list))
            {
                list = [];
                endpointsByNamespace[rootNamespace!] = list;
            }

            foreach (var attr in attributes)
            {
                var info = ExposeToHttpEndpointHelpers.ExtractEndpointInfo(classSymbol, attr, source.Compilation);
                list.Add(info);
            }
        }

        foreach (var kv in endpointsByNamespace)
        {
            var ns = kv.Key;
            var endpoints = kv.Value;
            GenerateClientForNamespace(context, ns, endpoints.ToArray());
        }
    }

    private static void GenerateClientForNamespace(SourceProductionContext context, string namespaceName, EndpointInfo[] endpoints)
    {
        if (endpoints.Length == 0)
        {
            return;
        }

        const string service = "Service";
        var serviceName = namespaceName.EndsWith(service) ? namespaceName : $"{namespaceName}Service";
        var interfaceName = $"I{serviceName}";
        var clientName = $"{serviceName}Client";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using NOF;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {namespaceName} service client interface");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial interface {interfaceName}");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            var requestType = endpoint.RequestType.ToDisplayString();
            var responseType = endpoint.ResponseType?.ToDisplayString();
            var returnType = string.IsNullOrEmpty(responseType) ? "NOF.Result" : $"NOF.Result<{responseType}>";
            var methodName = endpoint.OperationName;

            sb.AppendLine("        /// <summary>");
            sb.AppendLine($"        /// Calls {endpoint.Route} endpoint");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <param name=\"request\">Request parameters</param>");
            sb.AppendLine("        /// <param name=\"completionOption\">When the operation should complete</param>");
            sb.AppendLine("        /// <param name=\"cancellationToken\">Cancellation token</param>");
            sb.AppendLine("        /// <returns>Task result</returns>");
            sb.AppendLine($"        Task<{returnType}> {methodName}Async({requestType} request, HttpCompletionOption completionOption = default, CancellationToken cancellationToken = default);");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {namespaceName} service client implementation");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial class {clientName} : {interfaceName}");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly HttpClient _httpClient;");
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Initializes a new instance of {clientName}");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"httpClient\">HTTP client</param>");
        sb.AppendLine($"        public {clientName}(HttpClient httpClient)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(httpClient);");
        sb.AppendLine("            _httpClient = httpClient;");
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var endpoint in endpoints)
        {
            var requestType = endpoint.RequestType.ToDisplayString();
            var responseType = endpoint.ResponseType?.ToDisplayString();
            var returnType = string.IsNullOrEmpty(responseType) ? "NOF.Result" : $"NOF.Result<{responseType}>";
            var methodName = endpoint.OperationName;
            var httpMethod = GetHttpMethod(endpoint.Method);

            sb.AppendLine("        /// <inheritdoc />");
            sb.AppendLine($"        public async Task<{returnType}> {methodName}Async({requestType} request, HttpCompletionOption completionOption, CancellationToken cancellationToken)");
            sb.AppendLine("        {");

            sb.AppendLine(string.IsNullOrEmpty(responseType)
                ? $"            return await _httpClient.SendRequestAsync({httpMethod}, \"{endpoint.Route}\", request, completionOption, cancellationToken);"
                : $"            return await _httpClient.SendRequestAsync<{responseType}>({httpMethod}, \"{endpoint.Route}\", request, completionOption, cancellationToken);");

            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{serviceName}Client.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string GetHttpMethod(HttpVerb verb) => verb switch
    {
        HttpVerb.Get => "HttpMethod.Get",
        HttpVerb.Post => "HttpMethod.Post",
        HttpVerb.Put => "HttpMethod.Put",
        HttpVerb.Delete => "HttpMethod.Delete",
        HttpVerb.Patch => "HttpMethod.Patch",
        _ => throw new ArgumentOutOfRangeException(nameof(verb), verb, null)
    };
}

#region Helper
internal static class ExposeToHttpEndpointHelpers
{
    public static bool HasExposeToHttpEndpointAttribute(INamedTypeSymbol symbol)
    {
        return symbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString() == "NOF.ExposeToHttpEndpointAttribute");
    }

    public static bool IsRequestType(INamedTypeSymbol typeSymbol)
    {
        return typeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == "NOF.IRequest"
            || (i is { IsGenericType: true, ConstructedFrom.SpecialType: SpecialType.None }
                && i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"));
    }

    public static string? GetRootNamespace(INamespaceSymbol ns)
    {
        while (ns is not null && !string.IsNullOrEmpty(ns.Name))
        {
            if (ns.ContainingNamespace is null || string.IsNullOrEmpty(ns.ContainingNamespace.Name))
            {
                return ns.Name;
            }
            ns = ns.ContainingNamespace;
        }
        return null;
    }

    public static ITypeSymbol? GetResponseType(INamedTypeSymbol requestType)
    {
        var requestInterface = requestType.AllInterfaces
            .FirstOrDefault(i => i.OriginalDefinition.ToDisplayString() == "NOF.IRequest<TResponse>"
                                 && i.IsGenericType);

        return requestInterface is { TypeArguments.Length: 1 }
            ? requestInterface.TypeArguments[0]
            : null;
    }

    public static EndpointInfo ExtractEndpointInfo(
        INamedTypeSymbol classSymbol,
        AttributeData attr,
        Compilation compilation)
    {
        var method = (HttpVerb)attr.ConstructorArguments[0].Value!;
        var route = attr.ConstructorArguments.Length > 1
            ? attr.ConstructorArguments[1].Value as string
            : null;
        route = route?.TrimEnd('/');

        const string requestSuffix = "Request";
        var operationName = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "OperationName").Value.Value as string
            ?? (classSymbol.Name.EndsWith(requestSuffix)
                ? classSymbol.Name.Substring(0, classSymbol.Name.Length - requestSuffix.Length)
                : classSymbol.Name);

        route ??= operationName;

        var responseType = GetResponseType(classSymbol);
        var permission = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "Permission").Value.Value as string;
        var allowAnonymous = attr.NamedArguments
            .FirstOrDefault(arg => arg.Key == "AllowAnonymous").Value.Value is true;

        return new EndpointInfo
        {
            RequestType = classSymbol,
            ResponseType = responseType,
            Method = method,
            Route = route,
            OperationName = operationName,
            Permission = permission,
            AllowAnonymous = allowAnonymous
        };
    }
}

internal class EndpointInfo
{
    public INamedTypeSymbol RequestType { get; set; } = null!;
    public ITypeSymbol? ResponseType { get; set; }
    public HttpVerb Method { get; set; }
    public string Route { get; set; } = string.Empty;
    public string OperationName { get; set; } = string.Empty;
    public string? Permission { get; set; }
    public bool AllowAnonymous { get; set; }
}

internal enum HttpVerb
{
    Get,
    Post,
    Put,
    Delete,
    Patch
}
#endregion