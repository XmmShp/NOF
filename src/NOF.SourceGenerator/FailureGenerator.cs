using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF;

/// <summary>
/// 源生成器：检测标记了FailureAttribute的类，并生成静态错误实例
/// </summary>
[Generator]
public class FailureGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取所有带有FailureAttribute的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // 注册输出生成
        context.RegisterSourceOutput(classDeclarations.Collect(), static (spc, source) => Execute(source, spc));
    }

    /// <summary>
    /// 判断语法节点是否是生成目标（带有Attribute的类或record声明）
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return (node is (ClassDeclarationSyntax or RecordDeclarationSyntax) and TypeDeclarationSyntax { AttributeLists.Count: > 0 });
    }

    /// <summary>
    /// 获取语义模型目标
    /// </summary>
    private static FailureClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        // 获取类型的语义符号
        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;
        if (typeSymbol is null)
        {
            return null;
        }

        // 检查是否有FailureAttribute
        var errorAttributes = typeSymbol.GetAttributes()
            .Where(attr => attr.AttributeClass?.ToDisplayString() == "NOF.FailureAttribute")
            .ToList();

        if (errorAttributes.Count == 0)
        {
            return null;
        }

        // 检查是否是partial类型
        if (typeDeclaration.Modifiers.All(m => m.Text != "partial"))
        {
            return null;
        }

        var errors = (errorAttributes.Where(attr => attr.ConstructorArguments.Length == 3)
            .Select(attr => new { attr, name = attr.ConstructorArguments[0].Value?.ToString() ?? string.Empty })
            .Select(t => new { t, message = t.attr.ConstructorArguments[1].Value?.ToString() ?? string.Empty })
            .Select(t => new { t, errorCode = (int)(t.t.attr.ConstructorArguments[2].Value ?? 0) })
            .Where(t => !string.IsNullOrEmpty(t.t.t.name))
            .Select(t => new FailureInfo { Name = t.t.t.name, Message = t.t.message, FailureCode = t.errorCode })).ToList();

        if (errors.Count == 0)
        {
            return null;
        }

        return new FailureClassInfo
        {
            TypeName = typeSymbol.Name,
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
            IsRecord = typeDeclaration is RecordDeclarationSyntax,
            IsAbstract = typeSymbol.IsAbstract,
            Failures = errors
        };
    }

    /// <summary>
    /// 执行代码生成
    /// </summary>
    private static void Execute(ImmutableArray<FailureClassInfo?> errorClasses, SourceProductionContext context)
    {
        if (errorClasses.IsDefaultOrEmpty)
        {
            return;
        }

        var validClasses = errorClasses
            .Where(c => c is not null)
            .ToList();

        if (validClasses.Count == 0)
        {
            return;
        }

        // 为每个类生成代码
        foreach (var errorClass in validClasses)
        {
            var source = GenerateFailureClass(errorClass!);
            context.AddSource($"{errorClass!.TypeName}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    /// <summary>
    /// 生成错误类的部分类代码
    /// </summary>
    private static string GenerateFailureClass(FailureClassInfo errorClass)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {errorClass.Namespace}");
        sb.AppendLine("{");

        // 生成类或record声明
        var typeKeyword = errorClass.IsRecord ? "record" : "class";
        var abstractKeyword = errorClass.IsAbstract ? "abstract " : "";

        sb.AppendLine($"    public {abstractKeyword}partial {typeKeyword} {errorClass.TypeName}");
        sb.AppendLine("    {");

        // 生成静态错误实例
        foreach (var error in errorClass.Failures)
        {
            sb.AppendLine("        /// <summary>");
            sb.AppendLine($"        /// {error.Message}");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine($"        public static readonly NOF.Failure {error.Name} = new(\"{error.Message}\", {error.FailureCode});");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// 错误类信息
    /// </summary>
    private class FailureClassInfo
    {
        public string TypeName { get; set; } = string.Empty;
        public string Namespace { get; set; } = string.Empty;
        public bool IsRecord { get; set; }
        public bool IsAbstract { get; set; }
        public List<FailureInfo> Failures { get; set; } = [];
    }

    /// <summary>
    /// 单个错误信息
    /// </summary>
    private class FailureInfo
    {
        public string Name { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public int FailureCode { get; set; }
    }
}
