using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace NOF;

/// <summary>
/// 源生成器：检测标记了QueryParameterAttribute的类，并生成ToQueryString扩展方法
/// </summary>
[Generator]
public class QueryParameterGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取所有带有QueryParameterAttribute的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // 将语法和语义模型组合起来
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // 注册源代码输出
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    /// <summary>
    /// 判断语法节点是否是我们要处理的目标
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // 处理类、记录和结构体声明
        return node is TypeDeclarationSyntax typeDeclaration
            // 确保类型有特性列表
            && typeDeclaration.AttributeLists.Count > 0;
    }

    /// <summary>
    /// 获取语义模型中的目标类型
    /// </summary>
    private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        // 获取类型声明语法节点（类、记录或结构体）
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        // 获取类型的符号信息
        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);
        if (typeSymbol is null)
        {
            return null;
        }

        // 检查类型是否标记了QueryParameterAttribute
        var hasAttribute = typeSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString() == "NOF.QueryParameterAttribute");

        return hasAttribute ? typeDeclaration : null;
    }

    /// <summary>
    /// 生成源代码
    /// </summary>
    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax?> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var typeDeclaration in types)
        {
            if (typeDeclaration is null)
            {
                continue;
            }
            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);
            if (typeSymbol is null)
            {
                continue;
            }

            var typeName = typeSymbol.Name;
            var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();

            // 确定类型关键字
            var typeKeyword = GetTypeKeyword(typeDeclaration);

            // 获取所有公共属性，包括继承的属性
            var properties = GetAllProperties(typeSymbol)
                .Where(p => p.DeclaredAccessibility == Accessibility.Public)
                .ToList();

            var source = GenerateExtensionMethod(namespaceName, typeName, typeKeyword, properties);

            context.AddSource($"{typeName}.QueryParameter.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    /// <summary>
    /// 获取类型关键字
    /// </summary>
    private static string GetTypeKeyword(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration switch
        {
            RecordDeclarationSyntax record => record.ClassOrStructKeyword.IsKind(SyntaxKind.StructKeyword) ? "record struct" : "record",
            StructDeclarationSyntax => "struct",
            _ => "class"
        };
    }

    /// <summary>
    /// 生成实例方法代码
    /// </summary>
    private static string GenerateExtensionMethod(string namespaceName, string typeName, string typeKeyword, List<IPropertySymbol> properties)
    {
        var sb = new StringBuilder();

        // 添加必要的命名空间引用
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine();

        // 生成命名空间
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {typeName}的查询参数部分类型");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public partial {typeKeyword} {typeName}");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// 将对象转换为URL查询字符串");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <returns>URL查询字符串，如果有参数则以?开头</returns>");
        sb.AppendLine("        public string ToQueryString()");
        sb.AppendLine("        {");
        sb.AppendLine("            var queryParams = new Dictionary<string, string>();");
        sb.AppendLine();

        // 为每个属性生成查询参数代码
        foreach (var propertyName in properties.Select(property => property.Name))
        {
            sb.AppendLine($"            queryParams[\"{propertyName}\"] = {propertyName}?.ToString();");
        }

        // 调用 ConfigureQueryString 方法
        sb.AppendLine();
        sb.AppendLine("            var queryStringParts = new List<string>();");
        sb.AppendLine("            foreach (var param in queryParams)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (string.IsNullOrEmpty(param.Value))");
        sb.AppendLine("                {");
        sb.AppendLine("                    continue;");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                var escapedKey = Uri.EscapeDataString(param.Key);");
        sb.AppendLine("                var escapedValue = Uri.EscapeDataString(param.Value);");
        sb.AppendLine("                queryStringParts.Add($\"{escapedKey}={escapedValue}\");");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            return queryStringParts.Count > 0 ? \"?\" + string.Join(\"&\", queryStringParts) : \"\";");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// 获取类型的所有属性，包括继承的属性
    /// </summary>
    private static IEnumerable<IPropertySymbol> GetAllProperties(ISymbol classSymbol)
    {
        if (classSymbol is not INamedTypeSymbol currentType)
        {
            yield break;
        }

        var allProperties = new Dictionary<string, IPropertySymbol>();

        var baseTypes = new List<INamedTypeSymbol>();
        var type = currentType;

        while (type is not null && type.SpecialType != SpecialType.System_Object)
        {
            baseTypes.Add(type);
            type = type.BaseType;
        }

        baseTypes.Reverse();
        foreach (var member in baseTypes.SelectMany(namedType => namedType.GetMembers().Where(m => m.Kind == SymbolKind.Property)))
        {
            if (member is IPropertySymbol property)
            {
                allProperties[property.Name] = property;
            }
        }

        foreach (var property in allProperties.Values)
        {
            yield return property;
        }
    }
}
